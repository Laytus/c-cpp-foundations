# Module 1.7 – Pasing Pointers to Functions

### Learning Goals
- Explain **why C functions cannot modify variables by default**
- Understand how **passing a pointer enables modification**
- Predict what happens to values when:
    - **passing by value**
    - **passing by pointer**
- Explain the role of pointers in **C APIs**
- Reason about pointer validity across functions calls
- Verify behavior using the debugger

---

## The problem: functions receive copies

Ler's consider this code:
```c
#include <stdio.h>

void change(int x) {
    x = 100;
}

int main(void) {
    int a = 10;
    change(a);
    printf("a = %d\n", a);
    return 0;
}
```

What happens?
- `a` is passed to change
- `change`receives a **copy** of `a`
- Modifying `x` does **not** affect `a`

Output:
```c
a = 10
```

Why?
> **C passes arguments by value. Always.**

---

## The solution: pass the address instead

If we want a function to modify a variable it didn't create, we must give it **access to the memory where that variables lives**.

That means: **pass its address**.

---

## Passing a pointer to a function

**c/fundamentals/pass_pointer_1.c**
```c
#include <stdio.h>

void change(int *x) {
    *x = 100;
}

int main(void) {
    int a = 10;
    change(&a);
    printf("a = %d\n", a);
    return 0;
}
```

### What happens step by step (conceptually)

```c
int a = 10;
```

- `a` exists in `main`'s stack frame

```c
change(&a);
```

- The **address of `a`** is passed
- `change` receives a *pointer* to `a`

```c
*x = 100;
```

- *Dereference* the pointer
- Write directly to `a`'s memory

Now `a` is modified.

---

## This is the core rule

> **Functions cannot modify external variables unless they receive a pointer to them.**

This is the fundation of:
- output parameters
- in-place modifications
- C APIs
- array manipulation
- dynamic memory APIs

---

## Visualizing stack frames

While inside `change`:
```
+------------------+
| change frame     |
|  x (pointer)     | → points to a
+------------------+
| main frame       |
|  a = 10 → 100    |
+------------------+
```

Key insight:
- `a` lives in `main`
- `change` only knows **where `a` lives**
- Dereferencing bridges the frames

---

## Why this pattern is everywhere in C

Advanced example:
```c
scanf("&d", &x);
fgets(buffer, size, stdin);
malloc(size);
```
These APIs:
- receive pointers
- operate on memory they didn't allocate
- rely entirely on this mechanism

---

## Pointer validity across function calls

Important rule:
> **Passing a pointer does NOT extend the lifetime of the object it points to.**

Safe:
```c
int a;
change(&a);
```

Unsafe:
```c
int* bad(void) {
    int x;
    return &x;
}
```

---

### Takeaway

> *C functions* **receive arguments** by **value**.  
> **Passing a variable** passes a **copy** of its **value**.  
> To *modify a variable* in *another function*, its **address** must be *passed*.  
> A **pointer parameter** allows a function to *access external memory*.  
> Dereferencing inside a function *modifies* the **caller's data**.  
> Passing a pointer does **not** change the *lifetime* of the *pointed object*.  
> This pattern is the basis of most C APIs.