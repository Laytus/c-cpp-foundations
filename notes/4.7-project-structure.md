# Moduel 4.7 – Project Structure

### Learning Goals

- Organize a C project in a scalable way
- Separate public headers from private implementation
- Structure code for growth
- Understand include paths
- Prepare a project for real builds
- Avoid structural chaos early

---

## Why Project Structure matters

Without structure:
- Headers get mixed with sources
- Internal APIs leak
- Builds become fragile
- Scalling becomes painful
- Dependency graphs become unclear

Structure is architectural discipline.

---

## Minimal Professional Structure

For our current level and project size:
```
c-project/
│
├── include/
│   └── int_vector.h
│
├── src/
│   └── int_vector.c
│
├── app/
│   └── int_vector_main.c
│
├── build/
│   └── (object files, binaries)
│
├── docs/
│   └── (markdown notes)
│
└── README.md
```

---

## Why separate `include/` and `src/`

**`include/`**
- Public API headers
- What other modules are allowed to use

**`src/`**
- Implementation
- Internal helpers
- Private headers (if any)

This enforces API boundaries.

---

## Where should Headers live?

Rule:
> Headers that define *public interfaces* → `include/`

Internal headers (if needed later) can live in:
```
src/internal/
```

But for now:
- Keep it simple

---

## How to compile with this structure

From project root:
```bash
clang -std=c17 -Wall -Wextra -Werror -O0 -g \
  -fsanitize=address,undefined \
  app/int_vector_main.c src/int_vector.c \
  -Iinclude \
  -o build/app
```

Explanation:
- `-Iinclude` tells the compiles:
> "When resolving `#include "int_vector.h"`, look in the `include/` directory."

---

## Update the includes

In `int_vector_main.c`:
```c
#include "int_vector.h";
```

Not:
```c
#include "../include/int_vector.h";
```

We use `-I` to avoid relative include paths.

Professional code avoids relative include paths in source.

---

## Object files in `build/`

Compile to object files:
```bash
clang -c src/int_vector.c -Iinclude -o build/int_vector.o
clang -c src/int_vector_main.c -Iinclude -o build/main.o
```

Then link:
```bash
clang build/main.o build/int_vector.o -o build/app
```

This matches how real build systems work.

---

## Why this structure scales

Let's imagine adding:
- `buffer.c`
- `hash_table.c`
- `file_utils.c`

The project becomes:
```
include/
  int_vector.h
  buffer.h
  hash_table.h

src/
  int_vector.c
  buffer.c
  hash_table.c
```

Everything stays clean.

---

## Separate Compilation – Professional Workflow

**Better Practice: Professional Compilation Workflow**

In professional C development, source files are **compiled separately** and **linked afterward**.

Instead of compiling everything in one single command like:
```
clang int_vector_main.c int_vector.c buffer.c hash_table.c -o app
```

The recommended workflow is:

#### Step 1 – Compile each Source File independently

```bash
clang -std=c17 -Wall -Wextra -Werror -O0 -g -c src/int_vector.c -Iinclude -o build/int_vector.o
clang -std=c17 -Wall -Wextra -Werror -O0 -g -c src/buffer.c -Iinclude -o build/buffer.o
clang -std=c17 -Wall -Wextra -Werror -O0 -g -c src/hash_table.c -Iinclude -o build/hash_table.o
clang -std=c17 -Wall -Wextra -Werror -O0 -g -c app/main.c -Iinclude -o build/main.o
```

The `-c` flag means:
> Compile only. Do not link.

Each `.c` produces one `.o` (object file).

#### Step 2 – Link Object Files

```bash
clang build/main.o build/int_vector.o build/buffer.o build/hash_table.o -o build/app
```

The linker:
- Resolves undefined symbols
- Combines machine code
- Produces the final executable

**Why this is professional practice**

This approach:
- Scales to large systems
- Allows incremental builds
- Reduces compilation time
- Separates compilation from linking
- Matches how Makefiles, CMake, and real build systems work

In real-world systems, this is not optional – it is mandatory.

---

## Why Separate Compilation is important

Separate compilation is fundamental to how C scales.

#### 1. Translation Units are independent

Each `.c` file is compiled into its own translation unit.

This means:
- The compiler processes each file independently
- It does not require full program knowledge ar compile time
- It relies only on headers for external declarations

This design enables modular architecture.

#### 2. Incremental Builds

If we modify only:
```
hash_table.c
```

We only need to recompile:
```
hash_table.c → hash_table.o
```

We do **not** need to recompile:
- `int_vector_main.c`
- `buffer.c`
- `int_vector.c`

The we relink.

This drastically reduces build times in large systems.

#### 3. Enables Large-Scale Architecture

Separation compilation allows:
- Clear module boundaries
- Encapsulation through headers
- Private implementation dtails
- Independent development of components
- Team collaboration

Each module can evolve independelty as long as its public interface remains stable.

---

## Professional Expansion (Future)

Later we may add:
```
tests/
  test_vector.c

lib/
  (static libraries)

cmake/
  Makefile
```

---

## Final Mental Model

```
Headers (.h) → compile-time contracts
Sources (.c) → compiled into object files
Object files (.o) → linked together
Executable → final program
```

---

## Common Beginner Mistakes

❌ **Mixing headers and sources randomly**

❌ **Using relative include paths (`../`)**

❌ **Putting implementation in headers**

❌ **Dumping build artifacts next to source files**

❌ **No build directory separation**

---

## Why this matters

Real systems:
- Have dozens of modules
- Separate API from implementation
- Are compiled independently
- Use include directories
- Enforce boundaries

---

## Practical Step

Reestructure the example project to:
```
include/
src/
app/
build/
docs/
```

Move files accordingly.

Update compile commands.

Test that everything still builds and runs.

---

## Takeaway

> - *Separate* **public headers** (`include/`) from **implementation** (`src/`).  
> - Keep *application entry* in `app/`.  
> - Store *build artifacts* in `build/`.  
> - Use `-Iinclude` instead of relative include paths.  
> - Keep modules isolated and scalable.  
> - Project structure is architectural discipline.  