# Lifetime vs Scope

### Learning Goals:
- Separate **when something exists** from **where it can be used**.

---

## Two concepts that are often confused

#### Concept A - Lifetime
> Lifetime answers: **When does this object exist?**

Controlled by:
- **stack frame creation/destruction**
- **program start/end**

Independent of **where** you are in the code.


#### Concept B - Scope

> Scope answers: **Where can I refer to this object by name?**

Controlled by:
- **`{}` blocks**
- **function bodies**

Purely a **language rule**.

---

## Why C separates these concepts

In many high-level languages:
- lifetime and scope are tied together
- we don't notice the difference

**In C:**
- they are **separate on purpose**
- **understanding the separation is mandatory**

---

## First exercise

**c/fundamentals/lifetime_vs_scope_1.c**
```c
#include <stdio.h>

int main(void) {
    int x = 10;

    if (x > 0) {
        int y = 20;
        printf("Inside block: x = %d, y = %d\n", x, y);
    }

    printf("Outside block: x = %d\n", x);
    return 0;
}
```

1. While inside the if block, which variables exist?
**R:** Both `x` and `y`.

2. While inside the if block, which variables are visible?
**R:** Both `x` and `y`.

3. After the if block, does y still exist?
**R:** No, only `x` exist.

4. After the if block, is y still visible?
**R:** No, `y` is not visible.


### Correct reasoning

Inside the `if` block:
- **Exist**: `x`, `y`
- **Visible**: `x`, `y`

After the `if` block:
- **Exist**:
    - `x` → **yes** (`main`'s frame still exists)
    - `y` → **no** (its scope ended; lifetime ended)
- **Visible**:
    - `x` → **yes**
    - `y` → **no** (name is out scope)

**Important:**
> `y` does **not** exist anymore because its block ended.
> This is **not about memory reuse** yet - it's about **lifetime**

---

## Second exercise

**c/fundamentals/lifetime_vs_scope_2.c**
```c
#include <stdio.h>

void f(void) {
    int a = 1;
    printf("Inside f: a = %d\n", a);
}

void g(void) {
    int b = 2;
    f();
    printf("Inside g: b = %d\n", b);
}

void main(void) {
    int c = 3;
    g();
    printf("Inside main: c = %d\n", c);
    return 0;
}
```

### Key observation

While inside `f()`:
- `a` **exists** and is **visible**
- `b` **exists** and is **not visible**
- `c` **exists** and is **not visible**

> **An object can exist without being accessible.**

---

## First intentional `undefined behavior` (no pointers yet)

```c
#include <stdio.h>

int main(void) {
    int x;

    if (1) {
        int y = 5;
        x = y;
    }

    printf("%d\n", y);  // ← focus here
    return 0;
}
```

What happens?
- `y` is **out of scope** (`printf("%d\n", y);`)
- The compiler should **reject this**
- This is a **scope error**, not a runtime bug

To compare with:
```c
#include <stdio.h>

int main(void) {
    int x;

    if (1) {
        int y = 5;
        x = y;
    }

    printf("%d\n", x);
    return 0;
}
```

This **compiles**, but:
- If `x` was never initialized elsewhere
- Its value may be garbage
- For example, if the `if` block **does not execute**,
- That means:
    - `x` may never be assigned
    - `x` is then **read uninitialized**
- This is **`undefined behavior` at runtime**

Why the debugger can't "warn" us here:
- The compiler **cannot guarantee** the `if` runs
- The debugger **cannot know** whether `x` was initialized on all paths
- The program may:
    - appear to work
    - print "reasonable" values
    - fail only under optimization

This shows:
> **scope errors** → **compile-time**
> **lifetime/initialization errors** → **runtime**

---

## Takeaway

> **Lifetime answers *when memory exists***
> **Scope answers *where names are valid***
> **Objects can exist but be invisible**
> **Some bugs are caught by the compiler**
> **Others only appear at runtime**