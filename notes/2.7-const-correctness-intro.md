# Module 2.7 – Const Correctness (Intro)

### Learning Goals
- Explain what `const` means in C (and what it does *not* mean)
- Use `const` to express **intent** in function interfaces
- Understand how `const` relates to **ownership and mutation**
- Read and write `const` pointer declarations correctly
- Prevent accidental array and string modification
- Recognize when `const` should be used by default

---

## What `const` actually means

> **`const` means: "This object must not be modified through this name."**

Important:
- `const` is about **access**, not *existence*
- `const` does **not** mean "immutable forever"
- `const` is enforced at **compile time**

---

## `const` on variables

```c
const int x = 10;
x = 20; // ❌ compile-time error
```

This says:
- `x` cannot be modified after initialization

---

## Why `const` matters more with pointers

Pointers introduce **two different things**:
1. The pointer itself (the address)
2. The object it points to

`const` can apply to **either**.

---

## The three most important pointer forms

1. **Pointer to `const` data (most common)**
```c
const int *p;
```

Read as:
> "`p` points to a `const` `int`"

Meaning:
- We **cannot modify** the pointed-to value
- We **can change** where `p` points
```c
*p = 10; // ❌
p = &x;  // ✅
```

This is what we use it for:
- read-only arrays
- strings
- input parameters

2. **`Const` pointer to mutable data**
```c
int *const p = &x;
```

Read as:
> "`p` is a `const` pointer to `int`"

Meaning:
- We **can modify** the value
- We **cannot change** the pointer
```c
*p = 10; // ✅
p = &y;  // ❌
```

Less common, but useful in low-level code.

3. **`Const` pointer to `const` data

```c
const int *const p = &x;
```

Meaning:
- We cannot modify **neither** the *pointer* nor the *data*

Maximum restriction.

---

## The rule to read `const` declarations

> **Read `const` from right to left.**

Examples:
```c
const int *p;  // p → pointer → to const int
int *const p;  // p → const pointer → to int
const int *const p;
```

This rule scales to complex declarations.

---

## `const` and arrays

Arrays decay to pointers, so this is critical.

**Read-only array parameter**
```c
void print_array(const int *arr, size_t n);
```

This guarantees:
- the function will not modify the array
- callers can safely pass literals or read-only memory

This is **professional-grade API design**.

---

## `const` and strings

Correct signature:
```c
void print(const char *s);
```

Why?
- string literals are read-only
- modifying them is UB
- `const` enforces safety

Without `const`, this is allowed (but wrong):
```c
void print(char *s); // ❌ misleading
```

This falsely implies the function may modify the string.

---

## What `const` does NOT do

Important limitations:
- `const` does NOT:
    - **allocate memory**
    - **extend lifetime**
    - **prevent aliasing**
    - **make code thread-safe**

It only controls **how we may access memory**.

---

## Why `const` prevents bugs

Using `const`:
- documents intent
- enables compiler diagnostics
- prevents accidental writes
- makes APIs self-explanatory

Most C APIs are safer simply by adding `const`.

---

## Takeaway
> `const` restricts modification through a name.  
> `const` does not change object tlifetime or ownership.  
> With pointers, `const` can apply to the data or the pointer.  
> `const T *` means "read-only data".  
> Use `const` for array and string input parameters.  
> `const` expresses intent and prevents accidental bugs.  