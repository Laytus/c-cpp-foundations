# Module 4.8 – Error Handling Patterns

### Learning Goals

- Design functions that fail predictably
- Use consistent return-value conventions
- Write safe cleanup logic
- Handle partial initialization safely
- Avoid leaks during failure
- Understand the `goto cleanup` pattern
- Write robust multi-step initialization

---

## The Core Problem

C has:
- No exceptions
- No automatic stack unwinding
- No RAII (like C++)

If something fails:
> We must clean up manually.

If we forget:
- Memory leaks
- Resource leaks
- Corrupted state
- Undefined behavior

---

## Basic Error Signaling Convention

Most C functions follow this pattern:
| Return Value | Meaning |
|--------------|---------|
| 0 | Success |
| Non-zero | Error |

Example:
```c
int vec_init(IntVector *v, size_t capacity);
```

Return:
- `0` → success
- `-1` → failure

---

## Caller Responsability Pattern

Correct usage:
```c
IntVector v;

if (vec_init(&v, 10) != 0) {
    return ERROR;
}
```

Never ignore return values.

Ignoring return values = silent failure.

---

## Multi-step Initialization Problem

Let's consider:
```c
int init_system(System *s) {
    s->buffer = malloc(...);
    if (!s->buffer) return -1;

    s->table = malloc(...);
    if (!s->table) return -1;  // BUG: buffer leaks

    return 0;
}
```

If seconf allocation fails:
- First allocation is leaked

This is a classic C bug.

---

## The Correct Pattern: `goto cleanup`

This is the professional pattern used in:
- Linux kernel
- Databases
- Embedded systems
- System libraries

Example:
```c
int init_system(System *s) {
    s->buffer = NULL;
    s->table = NULL;

    s->buffer = malloc(...);
    if (!s->buffer)
        goto cleanup;
    
    s->table = malloc(...);
    if (!s->table)
        goto cleanup;

    return 0;

cleanup:
    free(s->table);
    free(s->buffer);
    return -1;
}
```

Why this is good:
- Single cleanup block
- No duplicated free logic
- Safe partial cleanup
- Easy to extend

### Always free in reverse order of acquisition

This rules comes from dependency ordering.

When we acquire resources step-by-step:
```c
A = acquire_A();
B = acquire_B(A);
C = acquire_C(B);
```

There is usually an implicit dependency chain:
```
C depends on B
B depends on A
```

So the safe destruction order is:
```
destroy C
destroy B
destroy A
```

This is called **LIFO order (Last In, First Out)** – like a stack.

---

## Why `goto` is acceptable here

`goto` is bad for control flow spaghetti.

But it is excellent for:
> Structured cleanup at function end.

This patter is disciplined and widely accepted.

---

## Consistent Error Conventions

Choose one of these patterns:

#### Pattern A – 0 success, non-zero error
```c
return 0;
return -1;
```

#### Pattern B – `NULL` on failure
```c
return NULL;
```

For constructors:
```c
Buffer *buffer_create(...);
```

Return:
- Pointer on success
- `NULL` on failure

---

## Defensive Initialization

Always initialize fileds before risky operations:
```c
s->buffer = NULL;
s->table = NULL;
```

So that cleanup is always safe:
```c
free(NULL);  // safe in C
```

This is critical discipline.

---

## Avoiding Double-Free

Good destroy pattern:
```c
void buffer_destroy(Buffer *b) {
    free(b->data);
    b->data = NULL;
}
```

Nullifying after free prevents:
- Accidental double free
- `use-after-free`

---

## Error Propagation

To propagate an error means:
> When a function fails, it informs its caller instead of silently handling it.

When callling sub-functions:
```c
if (vec_push(&v, x) != 0)  // sub-function propagated
    goto cleanup;
```

Do not swallow errors. Propagate them.

**Why propagation matters**

If we suppress errors:
- Debugging becomes impossible
- Systems behave unpredictably
- Failures appear far from origin
- Bugs compound silently

If we propagate:
- Failures are handled at appropriate level
- Control flow stays explicit
- Responsability is clear

---

## Logging vs Silent Failure

In libraries:
- Do not `printf` errors.
- **Return error codes.**
- Leave policy decisions to caller.

In applications:
- We may log or print.

Separation of concerns.

---

## Clean Patter Summary

Typical robust function:
```c
int function(...) {
    int result = -1;
    ResourceA a = NULL;
    ResourceB b = NULL;

    a = acquire_a();
    if (!a) goto cleanup;
    
    b = acquire_b();
    if (!b) goto cleanup;

    result = 0;

cleanup:
    release_b(b);
    release_a(a);
    return result;
}
```

Single exit.
Single cleanup.
Deterministic behavior.

---

## Takeaway

> - Use `0` for *success*, *non-zero* for *error*.  
> - Never ignore return values.  
> - Initialize resources to `NULL` before allocation.  
> - Use `goto cleanup` for multi-step initialization.  
> - Always free in reverse order of acquisition.  
> - Propagate errors instead of hiding them.  
> - Libraries should return errors, not print them.  
> - `free(NULL)` is safe and simplifies cleanup logic.  