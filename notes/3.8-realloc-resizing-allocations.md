# Module 3.8 – `malloc` (Resizing Allocations)

## Learning Goals

- Explain what `realloc` does internally
- Understnad when `realloc` moves memory
- Use `realloc` **safely**
- Handle `realloc` failure correctly
- Avoid common `realloc` bugs
- Resize dynamic arrays without leaks or corruption

---

## What `realloc` is

Prototype:
```c
void *realloc(void *ptr, size_t new_size);
```

`realloc`:
- **resizes** an *existing heap allocation*
- may **move** the memory
- preserves existing data (up to the moninimum of old/new size)
- **returns a pointer** to the resized block
- **returns `NULL`** on failure

---

## What `realloc` actually does (conceptually)

When we call:
```c
p = realloc(p, new_size);
```

The allocator may:
1. **Extend in place**
    → pointer stays the same
2. **Allocate a new block + copy + free old block**
    → pointer changes
3. **Fail**
    → returns `NULL`, original memory is untouched

We **cannot assume** which case occurs.

---

## The most dangerous `realloc` bug

❌ **WRONG:**
```c
p = realloc(p, new_size);
if (!p) {
    // lost original pointer → leak
}
```

If `realloc` fails:
- `p` becomes `NULL`
- original allocation is leaked
- ownership is lost

This is one of the most common C bugs.

---

## The correct `realloc` pattern

✅ **RIGHT:**
```c
void *tmp = realloc(p, new_size);
if (!tmp) {
    // allocation failed
    // p is still valid
    return ERROR;
}
p = tmp;
```

Rule:
> **Never overwrite the pointer with `realloc` directly.**

---

## Resizing a dynamic array safely

Example: grow an array from `n` to `new_n`
```c
int *tmp = realloc(arr, new_n * sizeof(int));
if (!tmp) {
    //handle failure, arr is still valid
    return;
}
arr = tmp;
```

After success:
- old data is preserved
- new elements are uninitialized
- ownership continues

---

## Shrinking allocations
```c
arr = realloc(arr, smaller_n * sizeof(int));
```

- valid
- dat beyond new size is lost
- memory may or may not move

Shrinking is safer than growing – but still use the safe pattern.

---

## `realloc(NULL, size)` special case

This is valid:
```c
p = realloc(NULL, size);
```

It behaves exactly like:
```c
p = malloc(size);
```

This allows unified allocation logic.

---

## `realloc(ptr, 0)` – dangerous edge case

This is **implementation-defined**:
```c
realloc(p, 0);
```

It may:
1. free the memory and return `NULL`
2. free the memory and return a **non-`NULL`pointer** (**unique pointer**) that:
    - cannot be *dereferenced*
    - must be passed to `free`
    - is *distinct from any other allocation* 

**What does "unique pointer" means?**
- The pointer value is **unique**
- It does **not point to usable memory**
- It exists *only* so it can later be passed to `free`
- *Dereferencing* it is *undefined behavior*

**Do not rely on this behavior.**

Explicit is better:
```c
free(p);
p = NULL;
```

---

## Ownership rules with `realloc`

- Ownership is preserved if `realloc` succeeds
- Onwerhsip remains with the original pointer if it fails
- Old pointers become invalid **only after successful `realloc`**

This is why the temp-pointer pattern is critical.

---

## Common `realloc` bugs

❌ **Losing the pointer**
```c
arr = realloc(arr, new_size);   // ❌ 
```

❌ **Forgetting to update aliases**
```c
int *alias = arr;
arr = realloc(arr, new_size);
*alias[0] = 42;   // ❌ a may be dangling pointer → use-after-free
```

**REMEMBER: what is an alias?**
An **alias** is *another pointer* that refers to the same memory.
```c
int *arr = malloc(10 * sizeof(int));
int *alias = arr;
```

Now:
- `arr` and `alias` point to the same block
- There is **still only one owner**

Here's what may happen:

**Case 1: `realloc` grows in place**
- `arr` stays the same
- `alias` reamins valid
- Everything works

**Case 2: `realloc` moves memory**
- Old block is freed
- New block is allocate elsewhere
- `arr` is updated
- **`alias` still points to freed memory**

> **After successful `realloc`, all aliases must be considered invalid.**

❌ **Assuming memory didn't move**
```c
int *arr = malloc(5 * sizeof(int));
realloc(arr, 10 * sizeof(int));
arr[0] = 1;   // ❌ UB if realloc moved memory
```

Why is this wrong?

Because:
- `realloc` may move memory
- We ignored the return value
- `arr` may still point to freed memory

If `realloc` moved the block:
- the old memory was freed
- `arr` is now dangling

**Summary table**
| Bug | What goes wrong |
|-----|-----------------|
| `realloc(prt, 0)` | Unpredictable behavior |
| Forgetting aliases | Some pointers still refer to freed memory |
| Assuming no move | Using stale pointer values |
| Ignoring return | Losing ownerhsip or accessing freed memory |

---

## Debugging `realloc` issues

AddressSanitizer detects:
- `use-after-free`
- `out-of-bounds` access
- invalid heap usage

Compile with:
```bahs
-fsanitize=address,undefined
```

Without ASan, `realloc` bugs are extremely hard to diagnose.

---

## Takeaway

> - `realloc` resizes an existing *heap allocation*.  
> - It may *move memory* or *resize in place*.  
> - On failure, `realloc` returns `NULL` and leaves the original allocation untouched.  
> - Never overwrite the pointer with `realloc`.  
> - Always use a **temporary pointer** when calling `realloc`.  
> - All existing pointers become invalid if `realloc` moves memory.  
> - New memory after growth is uninitialized.  