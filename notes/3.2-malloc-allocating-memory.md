# Module 3.2 – malloc (Allocating Memory)

### Learning Goals
- Explain what `malloc` does and does *not* do
- Understand what `malloc` returns and why
- Allocate memory correctly for single objects and arrays
- Use `sizeof` properly with malloc
- Handle allocation failure safely
- Explain why `malloc` memory is *uninitialized*
- Avoid the most common beginner mistakes with `malloc`

---

## What `malloc` is

`malloc` stands for **memory allocation**.

```c
void *malloc(size_t size);
```

It:
- requests **`size` bytes** from the **heap**
- returns a **pointer** to the *first byte*
- returns `NULL` if allocation fails

That's all it does.

It does **not**:
- initialize memory
- track ownership
- free memory automatically
- know what type we intend to store

---

## Why `malloc` returns `void *`

`void *` means:

> "Pointer to memory of unknown type."

This allows `malloc` to be **generic**.

We decide how that memory is interpreted:
```c
int *p = malloc(sizeof(int));
```

Here:
- `malloc` gives raw memory
- we *assign meaning* by storing it in `int *` 

---

## Casting `malloc`

**In C – do not cast `malloc`**

Correct:
```c
int *p = malloc(sizeof(int));
```

Incorrect (in C):
```c
int *p = (int *)malloc(sizeof(int));  // ❌
```

Why?
- Casting can hide missing `#include <stdlib.h>`
- The implicit conversion is safe in C
- Casting reduces compiler diagnostics

This is a **C-specific rule**. (C++ is different.)

---

## Allocating a single object

Example:
```c
int *p = malloc(sizeof(int));
```

This allocates:
- enough space for **one int**
- returns a **pointer** to it

⚠️ The *value* is **uninitialized**.

Using it immediately is UB:
```c
printf("%d\n", *p);  // ❌ UB
```

Correct:
```c
*p = 42;
printf("%d\n", *p);
```

---

## Allocating an array dynamically

Canonical pattern:
```c
size_t n = 10;
int *arr = malloc(n * sizeof(int));
```

Why this form matters:
- scales correctly if type changes
- avoids hardcoded sizes
- handles alignment properly

**Never do this:**
```c
malloc(10 * 4);  // ❌ fragile
```

---

## Always check for failure

`malloc` can fail.

Correct pattern:
```c
int *p = malloc(sizeof(int));
if (!p) {
    // handle allocation failure
}
```

If we *dereference* `NULL`, the program **crashes immediately**.

In real systems:
- low memory happens
- allocations fail
- ignoring this is not acceptable

---

## Uninitialized memory

Memory returned by `malloc` contains **whatever was there before**.

Example:
```c
int *p = malloc(sizeof(int));
printf("%d\n", *p);  // ❌ UB
```

This is not "zero" memory.

If we want zeroed memory:
- use `calloc`
- or initialize manually

---

## Lifetime recap

Heap memory allocated by `malloc`:
- exists until `free` is called
- survives function returns
- is independent of scope

Example (now valid):
```c
int *make(void) {
    int *p = malloc(sizeof(int));
    *p = 42;
    return p;  // ✅ valid
}
```

This was *impossible* with **stack memory**.

---

## The ownership rule

> **Whoever calls `malloc` owns the memory – until ownership is transferred.**

This means:
- the **owner** must eventually call `free`
- failling to do so is a **memory leak**

---

## Takeaway

> `malloc` allocates *raw, uninitilaized* **heap memory**.  
> It returns a `void *` that must be assigned a *type*.  
> In C, `malloc` should not be **cast**.  
> Always allocate using `sizeof(type)`.  
> `malloc` may fail and return `NULL`.  
> Memory from `malloc` exists until explicitly freed.  
> Allocating memory introduces ownership responsibility.