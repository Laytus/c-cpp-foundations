# Module 4.4 – Headers (.h) and Implementation (.c)

### Learning Goals
- Explain the purpose of `.h` vs `.c`
- Write a clean public API in a header
- Implement that API in a `.c` file
- Understand what `#include` really does
- Know what should (and should not) go in a header
- Use `static` to keep helpers private
- Build multi-dile programs correctly

---

## What a header is (and what it is not)

A header (`.h`) is **not compiled by itself**.

A **header** is:

> A file that is *textually included* into `.c` files by the preprocessor.

When we write:
```c
#include "vec.h"
```

The preprocessor essentially copies the contents of `vec.h` into the `.c` file before compilation.

So:
- headers define **interfaces**
- `.c` files contain **definitions (implementation)**

---

## What goes in a header

A header should contain:

✅ Type declarations (`struct`, `typedef`)
✅ Function declarations (prototypes)
✅ Constants/macros (sparingly)
✅ Documentation comments (recommended)

A header ahould **not** contain:

❌ Function definitions (except `static inline` special cases)
❌ Global variable definitions
❌ Private helpers
❌ Big internal includes unless required for the interface

---

## What goes in a `.c` file

A `.c` file contains:

✅ Function definitions (the code)
✅ Private helper functions (`static`)
✅ Private internal structs (if using opaque types)
✅ Internal includes

---

## Concrete example: turning IntVector into a module

Let's split exercise in **`c/fundamentals/init_destroy_pattern.c`** into two files:

**`c/fundamentals/int_vector.h` (public API)**
```c
#ifndef INT_VECTOR_H
#define INT_VECTOR_H

#include <stddef.h>  // size_t

typedef struct {
    int *data;
    size_t size;
    size_t capacity;
} IntVector;

int vec_init(IntVector *v, size_t initial_capacity);
void vec_destroy(IntVector *v);

int vec_push(IntVector *v, int value);
int vec_reserve(IntVector *v, size_t new_capacity);

#endif
```

**`c/fundamentals/int_vector.c` (implementation)**
```c
#include "int_vector.h"
#include <stdlib.h>. // malloc, realloc, free

static int vec_is_valid(const IntVector *v) {
    if (!v) return 0;
    if ((v->data == NULL) != (v->capacity == 0)) return 0;
    if (v->size > v->capacity) return 0;
    return 1;
}

int vec_init(IntVector *v, size_t initial_capacity) {
    if (!v) return -1;

    v->data = NULL;
    v->size = 0;
    v->capacity = 0;

    if (initial_capacity == 0) return 0;

    v->data = (int *)malloc(initial_capacity * sizeof(int));
    if (!v->data) return -1;

    v->capacity = initial_capacity;
    return vec_is_valid(v) ? 0 : -1;
}

void vec_destroy(IntVector *v) {
    if (!v) return;
    free(v->data);
    v->data = NULL;
    v->size = 0;
    v->capacity = 0;
}

int vec_reserve(IntVector *v, size_t new_capacity) {
    if (!v || !vec_is_valid(v)) return -1;
    if (new_capacity <= v->capacity) return 0;

    void *tmp = realloc(v->data, new_capacity * sizeof(int));
    if (!tmp) return -1;

    v->data = (int *)tmp;
    v->capacity = new_capacity;
    return vec_is_valid(v) ? 0 : -1;
}

int vec_push(IntVector *v, int value) {
    if (!v || !vec_is_valid(v)) return -1;

    if (v->size == v->capacity) {
        size_t new_cap = (v->capacity == 0) ? 1 : (v->capacity * 2);
        if (vec_reserve(v, new_cap) != 0) return -1;
    }

    v->data[v->size++] = value;
    return vec_is_valid(v) ? 0 : -1;
}
```

Key idea:
- `vec_is_valid` is `static` → private helper
- only API functions are non-static and declared in header

**`c/fundamentals/int_vector_main.c` (implementation)**
```c
#include "int_vector.h"
#include <stdio.h>

int main(void) {
    IntVector v;
    if (vec_init(&v, 4) != 0) return 1;

    for (int i = 0; i < 10; i++) {
        if (vec_push(&v, i * 10) != 0) {
            vec_destroy(&v);
            return 1;
        }
    }

    printf("size=%zu capacity=%zu\n", v.size, v.capacity);
    vec_destroy(&v);
    return 0;
}
```

---

## How to compile multi-file code

From the project root:
```bash
clang -std=c17 -Wall -Wextra -Werror -O0 -g -fsanitize=address,undefined \
  int_vector_main.c int_vector.c -o app
```

We must compile **all translation units** (all `.c` files) that contain required definitions.

---

## Deep Dive – `static`, `typedef`, Include Guards, and Module Pattern

### `static`

`static` in C has **different meanings depending on context**.

**A) `static` at the file scope (functions & global variables)**

**Example**
```c
static int helper(void) {
    return 42;
}
```

This means:
> This function has **internal linkage**.

Translation:
- It is visible only inside this `.c` file
- It cannot be called form other files
- The linker will not export its symbol

**Why we use it**

Because we want:
- Clear module boundaries
- Encapsulation
- No accidental symbol collisions
- Smaller global namespaces

Without `static`, this:
```c
int helper(void);
```

Would be globally visible across the entire program.

That's bad design unless intentional.

**Rule**

> If a function is not part of the public API, mark it `static`.

**B) `static` inside functions**

Example:
```c
void f(void) {
    static int counter = 0;
    counter++;
}
```

Here `static` means:
> The variable has static storage duration.

Meaning:
- It is allocated once
- It keeps its value between calls
- It is not re-created each time

### `typedef`

`typedef` creates an alias for a type.

It does **not** create a new type.

**Basic example**
```c
typedef unsigned long u64;
```

Now:
```c
u64 x = 10;
```

Is exactly the same as:
```c
unsigned long x = 10;
```

**Why we use `typedef` with `struct`**

Without `typedef`:
```c
struct IntVector v;
```

With `typedef`:
```c
typedef struct {
    int *data;
    size_t size;
    size_t capacity;
} IntVector;
```

Now we can write:
```c
IntVector v;
```

Much cleaner.

**Alternatice pattern (more common in real systems)**
```c
typedef struct IntVector {
    int *data;
    size_t size;
    size_t capacity;
} IntVector;
```

This allows:
- `struct IntVector` (explicit form)
- `IntVector`(alias form)

This is common in large C codebases.

**Why we use `typedef`**
- Improves readability
- Simplifies syntax
- Hides implementation details (later with opaque types)
- Makes APIs cleaner

### `#ifndef`, `#define`, `#endif` (Include Guards)

These are preprocessor directives.

They exist to prevent **multiple inclusion problems**.

**The Problem**

If a header is included twice:
```c
#include "int_vector.h"
#include "int_vector.h"
```

Without guards, this would cause:
- duplicated `struct` definitions
- duplicated declarations
- compiler errors

**The Pattern**
```c
#ifndef INT_VECTOR_H
#define INT_VECTOR_H

// header contents

#endif
```

**How it works**
1. First inclusion:
    - `INT_VECTOR_H` not defined
    - So code inside is included
    - `INT_VECTOR_H` gets defined
2. Second inclusion:
    - `INT_VECTOR_H` already defined
    - Preprocessor skips entire file

This guarantees:
> Header contents are included exactly once per compilation unit.

**Why the name is uppercase**

Convention:
- Macro names are uppercase
- Usually based on file name

Example:
- `int_vecto.h` → `INT_VECTOR_H`

**Modern alternative (non-standard but common)**
```c
#pragma once
```

Simpler, but not part of the C standard.

We use traditional guards for portability.

### Standard Pattern for Creating a Module

Let's formalize this cleanly.

#### Step 1 – Header (`int_vector.h`)

Responsabilities:
- Inlcude guards
- Public type definitions
- Public function declarations
- Minimal includes

Example:
```c
#ifndef INT_VECTOR_H
#define INT_VECTOR_H

#include <stddef.h>

typedef struct IntVector {
    int   *data;
    size_t size;
    size_t capacity;
} IntVector;

int  vec_init(IntVector *v, size_t initial_capacity);
void vec_destroy(IntVector *v);

int  vec_push(IntVector *v, int value);
int  vec_reserve(IntVector *v, size_t new_capacity);

#endif
```

#### Step 2 – Implementation (`int_vector.c`)

Responsabilities:
- Include its own header first
- Include necessary system headers
- Implement functions
- Keep helpers `static`

Example:
```c
#include "int_vector.h"
#include <stdlib.h>

static int vec_is_valid(const IntVector *v) {
    if (!v) return 0;
    if ((v->data == NULL) != (v->capacity == 0)) return 0;
    if (v->size > v->capacity) return 0;
    return 1;
}

/* function implementations */
```

**Why include header first?**

This is very important:
```c
#include "int_vector.h"
```

If the header is broken or incomplet, the implementation will fail to compile.

This enforces API correctness.

#### Step 3 – Consumer (`int_vector_main.c`)

Only includes the header:
```c
#include "int_vector.h"
```

It must not include internal implementation details.

### The Architecture

```
main.c
   ↓
int_vector.h  (interface)
   ↓
int_vector.c  (implementation)
```

`int_vector_main.c` depends only on the public contract.

### Summary Table

| Concept | What it Does | Why it Exists |
| `static` (file scope) | Internal linkage | Encapsulation |
| `typedef` | Type alias | Cleaner APIs |
| `#idndef` guards | Prevent multiple inclusion | Avoid redefinition errors |
| `.h` file | Declares interface | Separation of concerns |
| `.c` file | Implements behavior | Encapsulation + modularity |

---

## Takeaway
> - `.h` files declare the public interface (types + function prototypes).  
> - `.c` files define the implementation (function bodies).   
> - `#include` literally copies header text into the `.c` file before compilation.  
> - Headers should avoid function definitions ( except special inline cases).  
> - Private helpers belong in `.c` and should be marked `static`.  
> - Multi-file programs are built by compiling all `.c` files together (or separately + link).  
> - Use `static` for private functions in `.c` files.  
> - Use `typedef` to simplify struct usage.  
> - Use include guards in every define.  
> - Headers declare; `.c` files define.  
> - Implementation details stay inside `.c`.  
> - Always include own header first in the `.c` file.  