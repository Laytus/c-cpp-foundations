# Module 3.7 – Dynamic Arrays (Heap-Allocation Arrays)

### Learning Goals

- Allocate arrays dynamically on the *heap*
- Understand how *heap arrays* differ from *stack arrays*
- Track array size explicitly
- Pass dynamic arrays to functions safely
- Avoid common dynamic array bugs
- Reason about ownership and lifetime of *heap arrays*

---

## What is a dynamic array?

A **dynamic array** is simply:

> An array allocated on the *heap* instead of the *stack*.

There is **no special type** for dynamic arrays in C.

This:
```c
int *arr = malloc(10 * sizeof(int));
```

is a dynamic array of 10 `ints`.

---

## Why dynamic arrays exist

Stack arrays have limits:
```c
int a[1000000];   // ❌ may overflow stack
```

Dynamic arrays solve:
- **Runtime-sized arrays**
- **Large arrays**
- **Arrays that must outlive a scope**
- **Arrays returned from functions**

---

## Allocating a dynamic array (canonical pattern)

```c
size_t n = 10;
int *arr = malloc(n * sizeof(int));

if (!arr) {
    // handle allocation failure
}
```

Key points:
- `arr` points to the first element
- Memory is contiguous
- Elements are uninitialized

---

## Using a dynamic array

Dynamic arrays behave exactly like stack arrays **after allocation**:
```c
arr[0] = 1;
arr[1] = 2;
arr[9] = 42;
```

Indexing rules are identical.

⚠️ Bounds are **not checked**.

---

## Lifetime of a dynamic array

```c
void f(void) {
    int *arr = malloc(10 * sizeof(int));
    // valid here
}
// ❌ leaked unless freed
```

Dynamic arrays:
- are not tied to scope
- must be freed manually

Correct:
```c
free(arr);
arr = NULL;
```

---

## Ownership of dynamic arrays

The same ownership rules apply:
- The allocator owns the array
- Ownership can be transferred
- Exactly one `free`

Example (returning an array):
```c
int *make_array(size_t n) {
    int *arr = malloc(n * sizeof(int));
    return arr;   // ownerhsip transferred
}
```

Caller must free it.

---

## Passing dynamic arrays to functions

Functions **do not know the size** of *dynamic arrays*.

We must pass it explicitly:
```c
void print(const int *arr, size_t n);
```

Never rely on `sizeof(arr)` inside functions.

This is the same rule we learned in Module 2.

---

## Stack arrays vs heap arrays

| Aspect | Stack array | Heap array |
|--------|-------------|------------|
| Allocation | Automatic | `malloc` |
| Lifetime | Scope-based | Manual |
| Size known at compile time | Often | No |
| Needs `free` | No | Yes |
| Can be returned | No | Yes |

---

## Common dynamic array bugs

❌ **Forgetting to `free`**
```c
int *arr = malloc(n * sizeof(int));
// forgot free(arr)
```
→ memory leak

❌ **Using after `free`**
```c
free(arr);
arr[0] = 1;   // ❌ UB
```

❌ **Losing the pointer**
```c
arr = malloc(n * sizeof(int));
arr = NULL;   // ❌ leak
```

❌ **Wrong allocation size**
```c
malloc(n * 4);   // ❌ fragile
```

Always use `sizeof(type)`.

---

## Debugging dynamic arrays

Use AddressSanitizer:
```bash
-fsanitize=address,undefined
```

ASan detects:
- `out-of-bounds` access
- `use-after-free` 
- leaks

This is **non-optional** when learning *heap arrays*.

---

## Takeaway

> A **dynamic array** is a *heap-allocated contiguous block of memory*.  
> Allocate arrays using `malloc(n * sizeof(type))`.  
> Dynamic arrays behave like normal arrays when *indexed*.  
> **Array size** must be tracked explicitly.  
> Dynamic arrays must be freed exactly once.  
> Ownership rules apply to dynamic arrays.  
> **Bounds errors** on dynamic arrays are *undefined behavior*.  