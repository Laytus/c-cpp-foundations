# Module 2.6 – Common Array Bugs (and How to Debug Them)

### Learning Goals
- Recognized the most common array-related bugs in C
- Understand *why* these bugs happen (memory model, decay, bounds)
- Predict the symptoms these bugs cause
- Use **sanitizers + debugger** together to localize them
- Develop a systematic debugging checklist for array issues

---

## Bug #1 – Off-by-one (again, because it's everywhere)

Example
```c
int arr[4];

for (int i = 0, i <= 4; i**) {
    arr[i] = i;
}
```

What's wrong?
- Valid indices: `0...3`
- Loop writes to `arr[4]` $\rightarrow$ **one past the end**

Symptoms
- Program runs "fine"
- Crash later, somewhere else
- Random corruption

How to debug?
- Enable `AddressSanitizer`
- Look for `stack-buffer-overflow/heap-buffer-overflow`
- Check loop conditions: <= vs <

---

## Bug #2 – Using `sizeof` on array parameters

Example
```c
void f(int arr[]) {
    size_t n = sizeof(arr) / sizeof(arr[0]);
}
```

Why it's wrong
- `arr` is actually `int *``
- `sizeof(arr)` is size of pointer, not array

Symptons
- Loop runs too few or too many times
- Subtle corruption
- Compiler warnings (if enabled)

How to debug
- Look for warnings like:
```
sizeof on array function parameter
```
- Print sizes at call site vs inside function
- Fix by **passing the length explicitly**

---

## Bug #3 – Missing space for '`\0`' in strings

Example
```c
char s[5] = "hello"; // ❌ needs 6
```

Why it's wrong
- Strings require a `null terminator`
- Writing `"hello"` needs 6 bytes

Symptoms
- Garbage output
- Crashes in `printf`, `strlen`, etc.
- ASan reports read overflow

How to debug
- Check array size vs string literal length
- Inspect memory in debugger
- Always account for '`\0`' 

---

## Bug #4 – Treating non-strings as strings

Example
```c
char data[3] = {'a', 'b', 'c'};
printf("%s\n", data); // ❌ UB
```

Why it's wrong
- No '`\0`'
- Not a string, just bytes

Symptons
- Random output
- Over-reads
- Crashes far from the source

How to debug
- Ask: "is this *guaranteed* to be null-terminated?"
- Avoid `%s` unless the invariant is clear
- Print individual bytes if unsure

---

## Bug #5 – Writing through a decayed pointer without knowing size

Example
```c
void fill(int *arr) {
    for (int i = 0; i < 10; i++) {
        arr[i] = i;
    }
}
```

Called with:
```c
int a[5];
fill(a); // ❌ overflow
```

Why it's wrong
- Function assumes size it doesn't know
- Array decayed $\rightarrow$ size lost

Symptons
- Stack corruption
- Silent overwrites
- ASan crashes

How to debug
- Check function signature
- Look for missing size parameter
- Fix API: `void fill(int *arr, size_t n)`

---

## Bug #6 – Using uninitialized arrays

Example
```c
int arr[10];
printf("%d\n", arr[3]); // ❌
```

Why it's wrong
- Values are indeterminate
- Reading uninitialized memory is UB

Symptons
- Random values
- Behavior changes between runs
- Sanitizer warnings (`use-of-uninitialized-value`)

How to debug
- Initialized arrays explicitly
- Use sanitizers
- Step through initialization logic

---

## Bug #7 – Assuming arrays are copied

Example
```c
void f(int arr[]) {
    arr[0] = 99;
}

int main(void) {
    int a[3] = {1, 2, 3};
    f(a);
}
```

Why this surprises people
- Arrays decay to pointers
- Function modifies caller's memory

Symptons
- "Why did my array change?"
- Unexpected side effects

How to debug
- Arrays are never passed by value
- Trace pointer flow in debugger
- Use `const` when modification is not intended (next lesson)

---

## A debugging checklist

When array-related bugs appear, ask:
1. What are the valid indices?
2. Who owns this memory?
3. Is the size known here?
4. Has decay already happened?
5. Is there a missing '`\0`'?
6. Am I relying on `sizeof` incorrectly?
7. What does AddressSanitizer say?

---

## Takeaway
> Most array bugs are caused by bounds errors or lost size information.  
> Off-by-one errors are the most common array bug in C.  
> `sizeof` behaves differently before and after array decay.  
> Strings require explicit space for `'\0'`.  
> Not all `char` arrays are strings.  
> Sanitizers + compiler warnings are the fastest way to find array bugs.  