# Module 4.2 – Passing structs (by Value vs by Pointer)

### Learning Goals

- Understand what it means to pass a `struct` **by value**
- Understand what it means to pass a `struct` **by pointer**
- Predict when data is copied and when it is not
- Choose the correct passing style for APIs
- Understand how passing style affects performance, ownership, and mutability
- Read professional C functions signatures correctly

---

## Passing a `struct` by value

**Example**
```c
struct Point {
    int x;
    int y;
};

void move (struct Point p) {
    p.x += 1;
    p.y += 1;
}

int main(void) {
    struct Point a = {1, 2};
    move(a);
}
```

**What happens in memory**

- The **entire struct is copied** into the function
- `move` works on a **local copy**
- The original `struct` is unchanged

This is equivalent to:
> Passing all fields as individual parameters.

---

## When passing by value is good

Passing by value is appropriate when:
- The `struct` is **small** (few bytes)
- We want **isolation** from the caller
- The function should not modify the original
- We want simple semantics

Examples:
- small coordinate types
- configuration snapshots
- raturn values

---

## Passing a `struct` by pointer

**Example**
```c
void move(struct Point *p) {
    p->x += 1;
    p->y += 1;
}
```

Call:
```c
move(&a);
```

**What happens in memory**
- Only the pointer is copied
- Function operates on the **original `struct`**
- Changes are visible to the caller

This is **borrowing**, not copying.

---

## Mutability and `const`

**Read-only borrowing**

```c
void print(const struct Point *p) {
    printf("%d %d\n", p->x, p->y);
}
```

This expresses:
- function borrows the `struct`
- function must not modify it

This is **API intent**, enforced by compiler.

---

## Ownership is NOT transferred

Important:
```c
void f(struct Point *p);
```

This means:
- function borrows the `struct`
- function does NOT own it
- function must NOT free it

Passing by pointer does **not** imply ownership.

---

## Performance implications

| Method | Cost | Notes |
|--------|------|-------|
| By value | Copies `struct` | Cost grows with size |
| By pointer | Copies `pointer` | Constant cost |

Large structs should almost always be passed by pointer.

---

## Common mistakes

❌ **Modifying value copy unintentionally**
```c
void reset(struct Config c) {
    c.flag = 0;   // caller unchanged
}
```

Bug: changes don't persist.

❌ **Forgetting `const`**
```c
void print(struct Point *p);   // misleading
```

Implies modification is allowed.

❌ **Passing pointers when copy was intended**
```c
void save(struct Config *c);
```

Caller may expect *isolation*, but *mutation* occurs.

---

## Rule of thumb

> **Small structs → pass by value**  
> **Large structs → pass by pointer**  
> **Read-only → `const struct *`**  

This covers 90% of cases.

---

## Return values and structs

Returning structs by value is **allowed and common**:
```c
struct Point make_point(int x, int y) {
    return (struct Point){x, y};
}
```

Semantically (according to the C language rules):
- A **temporary `struct` Point value** is created
- That value is **returned by value**
- The caller receives **its own copy** of that `struct`

There is **no shared object** between callee and caller.

So conceptually, this is like:
```c
struct Point tmp;
tmp.x = x;
tmp.y = y;
return tmp;   // returned by value
```

> **Returning a `struct` by value returns a copy, not "the original `struct`".  
> But modern compilers usually optimize the copy away.

Modern compilers optimize this efficiently.

> **return-by-value is preferred when possible.**

---

## Takeaway

> - Passing a `struct` **by values** *copies all its fields*.  
> - Passing **by pointer** *borrows the original `struct`.  
> - *Pointer passing* allows **mutation**; *value passing* does **not**.  
> - `const struct *` expresses read-only borrowing.  
> - Passing by pointer does not transfer ownership.  
> - Choose passing style based on size and semantics.  