# Module 1.8 – Pointer Validity & First Real Undefined Behavior

### Learning Goals
- Define what makes a *pointer* **valid** or **invalid**
- Explain why a pointer can hold an address but still be unsafe
- Identify the **first real forms of undefined behavior** involving pointers
- Understanding the relationship between **lifetime** and **pointer validity**
- Use the debugger and sanitizers to detect invalid pointer use

---

## Pointer validity

> A *pointer* is **valid** if it points to an *object* whose **lifetime has not ended** and whose **storage is accessible**.

A pointer becomes **invalid** when:
- the object it points to *no longer exists*
- the memory has been *freed*
- the pointer was *never initialized correctly*

Validity is **not** about:
- wheter the pointer is *non-NULL*
- whether it "looks like" a reasonable address

---

## The first real undefined behavior

Let's consider:
```c
int* bad(void) {
    int x = 42;
    return &x;
}
```

What happens step by step
1. `x` is created on the stack
2. `&x` is returned
3. `bad()` returns
4. `x`'s lifetime ends
5. The returned pointer still holds an address
6. That address is now **invalid**

The pointer exists. The object does not.

---

## Why this is undefined behavior

**Undefined behavior** means:
> The C standard makes **no guarantees** about what happens next.

So dereferencing this pointer may:
- print `42`
- print garbage
- crash
- corrup unrelated data
- appear to work

All outcomes are allowed.

---

## Another real UB example: unitialized pointers

```c
int *p;
*p = 10;  // ❌ undefined behavior
```

What's wrong?
- `p` has an *indeterminate value*
- It points *somewhere*
- Dereferencing writes to an unknown location

This is not "dangerous" – is is **illegal behavior**.

---

## Pointer validity vs scope

This is subtle and essential:
- **Scope**: where a name is visible
- **Lifetime**: when an object exists

Example:
```c
int *p;
{
    int x = 5;
    p = &x;
}   // x goes out of scope AND lifetime ends

*p = 10;   // ❌ UB
```

Even if:
- `p` is still in scope
- the address still exists

The object does not.

---

## Detecting invalid pointer use

**With sanitizers (recommended)**

Compile with:
```bash
-fsanitize=address,undefined
```

Typical output:
```
ERROR: AddressSanitizer: stack-use-after-return
```

This is the **first concrete UB detector**.

> The debugger cannot tell if dereferencing is legal – only sanitizers can.

---

## The rule to internalize

> **A pointer does not extend the lifetime of the object it points to.**

Passing pointers around does not make memory live longer.
Ownership and lifetime are separate concerns.

---

## Takeaway

> **Pointer validity** depends on *object lifetime*, not *pointer value*.  
> A pointer can hold an address but still be invalid.  
> Dereferencing an invalid pointer causes **undefined behavior**.  
> Returning the address of a local variable is *undefined behavior*.  
> **Uninitialized pointers** are *invalid**.  
> *Scope* and *lifetime* are different concepts.  
> **Sanitizers** are the most reliable way to detect invalid pointer usage.  