# Module 2.1 – Arrays as Contiguous Memory

### Learning Goals
- Explain what an **array** is in terms of *memory layout*
- Understand that an array is a **contiguous block of memory**
- Relate arrays directly to **addresses and pointers**
- Predict how *array alements* are **laid out** in *memory*
- Explain why arrays and pointers are *closely related but not identical*
- Use the debugger to inspect array memory safely

---

## What an array really is

At the memory level:
> An **array** is a **sequence of elements stored next to each other in memory**.

Not conceptually. No logically. **Physically**.

If we have an array of 4 integers, memory looks like:
```
+----+----+----+----+
| 10 | 20 | 30 | 40 |
+----+----+----+----+
```

Each box is an `int`.
Each box has its **own address**.
They are **adjacent**.

---

## First array example

**c/fundamentals/arrays_1.c**
```c
#include <stdio.h>

int main(void) {
    int arr[4] = {10, 20, 30, 40};

    printf("arr[0] = %d\n", arr[0]);
    printf("arr[1] = %d\n", arr[1]);
    printf("arr[2] = %d\n", arr[2]);
    printf("arr[3] = %d\n", arr[3]);

    return 0;
}
```

---

## Why indexing works at all

When we write:
```c
arr[2]
```

C interprets this as:
> "Take the address of the first element, move forward by 2 elements, then read the value there."

No bounds checking. No safety net. **Just arithmetic on addresses.**

> This is why arrays are fast – and dangerous.

---

## Arrays and addresses (important relationship)

Let's inspect:
```c
p &arr
p &arr[0]
```

Output:
```bash
(int (*)[4]) 0x...820
(int *) 0x...820
```

We notice something interesting:
- `&arr[0]` $\rightarrow$ address of first element
- `&arr` $\rightarrow$ address of the whole array (same numeric value)

But **types differ** (`int *` vs `int (*)[4]`).

> **The array starts at the address of its first element.**

---

## Arrays are not pointers (but...)

- An **array**
    - owns a *block of memory*
    - has a *fixed size*
    - lives entirely in *one place*
- A **pointer**
    - *stores and address*
    - does *not* own memory
    - con point *anywhere*

However...
> **In most expressions, an array "decay" to a pointer to its first element.**

That's why arrays and pointers feel similar – but they are **not the same thing**.

---

## Visual model

For:
```c
int arr[4] = {10, 20, 30, 40};
```

Memory looks like:
```
Address      Value
--------     -----
&arr[0] ---> 10
&arr[1] ---> 20
&arr[2] ---> 30
&arr[3] ---> 40
```

No gaps. No metadata. Just raw memory.

---

## Why this matters

Because arrays are contiguous:
- Going past the end reads **someone else's memory**
- Writing past the end *corrupts data**
- Many security bugs are born here

---


## Takeaway
> An **array** is a **contiguous block of memory**.  
> Each *element* has its **own address**.  
> Array elements are **stored next to each other with no gaps**.  
> **Indexing** works by computing an **address offset**.  
> The array *starts* at the *address of its first element*.  
> Arrays are *closely related* to pointers but are not the same.  
> C performs no **bounds checking** on arrays.