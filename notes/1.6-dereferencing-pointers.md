# Module 1.6 â€“ Dereferencing pointers

### Learning Goals
- Explain what **deferencing a pointer** means in plain language
- Understand the difference between:
    - a **pointer's value** (an address)
    - the **value stored at that address**
- Predict what happens when a pointer is **valid** and **invalid**
- Explain why deferencing an invalid pointer leads to **undefined behavior**
- Use the debugger to safely inspect dereferenced values

---

## What "dereferencing" really means

We already know:
> A pointer is a value that stores an address.

So **dereferencing** simply means:
> **Go to the memory location stored in the pointer and read (or write) what is there.**


## The syntax

In C, dereferencing is written with `*`.

Example:
```c
*p
```

This reads as:
> "The value located at the address stored in p"

Important:
- `*p` is **not** the *pointer*
- `p` is the *pointer*
- `*p` is the **thing the pointer points to**

---

## First dereference example

**c/fundamentals/dereference_1.c**
```c
#include <stdio.h>

int main(void) {
    int x = 42;
    int *p = &x;

    printf("x value: %d\n", x);
    printf("*p value: %d\n", *p);

    return 0;
}
```

## What is happening

```c
int x = 42;
```

- Memory is reserved
- `42` is stored there

```c
int *p = &x;
```

- `p` stores the address of `x`

```c
*p
```

- Takes the address stored in `p`
- Go to that memory location
- Read the value there (`42`)

So:
- `x` and `*p` refer to **the same memory**
- They are two ways of accessing the same data

> **Dereferencing accesses the value stored at the pointed-to-address.**

---

## Writing through a pointer

```c
#include <stdio.h>

int main(void) {
    int x = 42;
    int *p = &x;

    printf("x value: %d\n", x);

    *p = 100;

    printf("x value: %d\n", x);
    return 0;
}
```

What happens?
- `*p = 100` writes **to the memory location of `x`**
- `x` changes because it lives there

Key idea:
> **Dereferencing allows both reading and writing memory.**

---

## Dereferencing invalid pointers (critical)

```c
int* bad(void) {
    int x = 42;
    return &x;
}
```

What happens if we do:
```c
int *p = bad();
printf("%d\n", *p);
```

Step by step:
1. `x` is created in `bad`'s stack frame
2. `p` receives `&x`
3. `bad` returns
4. `x`'s lifetime ends
5. `p` still stores the address
6. `*p` tries to read from an **invalid address**

This is **undefined behavior**.
Because we are dereferencing an address that no longer refers to a valid object.

Even if:
- it prints `42`
- it "works"
- the debugger shows something

---

## Important distinction

> **A pointer can have a value, but still be invalid to dereference.**

Validity is **not** about:
- the pointer being *non-null*
- the address "looking reasinable"

Validity is about:
- whether the pointed-to object still exists

---

## A very useful mental model

> **Pointer** $\rightarrow$ **house address**  
> **Dereference** $\rightarrow$ **entering the house**  

If the house was demolished:
- the address still exists
- entering is illegal

---

## Takeaway

> A *pointer* stores an **address**, not a value.  
> **Dereferencing** means *accessing the value stored at the address inside a pointer*.  
> `p`is the pointer; `*p` is the value it points to.  
> *Dereferencing* reads or writes directly to the pointed memory.  
> A pointer can exist while being *invalid* to dereference.  
> Pointer *validity* depends on the *lifetime* of the pointed object.  
> Dereferencing an *invalid pointer* causes **undefined behavior**, even if it appears to work.  
> *Undefined behavior* may not crash immediately and cannot be trusted.  