# Module 4.5 – Compilation Units & Linking

### Learning Goals

- Define what a **translation unit** is
- Explain what the **compiler** does vs what the **linker** does
- Understand what symbols are
- Diagnose:
    - "undefined reference"
    - "multiple definition"
- Understand how multi-file programs become one executable
- Understand internal vs external linkage at a deep level

---

## The Compilation Pipeline (High-Level View)

When we run:
```bash
clang int_vector_main.c int_vector.c -o app
```

The process is:
```
Preprocessing → Compilation → Assembly → Linking
```

#### Step 1: Preprocessing

Handles:
- `#include`
- `#define`
- `#idfef`

It literally **copies header contents** into `.c` files.

Each `.c` file becomes one big expanded source file.

#### Step 2: Compilation

Each `.c` file is compiled **independently** into an object file:
```
int_vector_main.c   → int_vector_main.o
int_vector.c        → int_vector.o
```

Each object file is called a:
> Translation Unit

---

## What is a Translation Unit?

A translation unit is:
> One `.c` file after preprocessing.

Each translation unit is compiled **in isolation**.

This is critical.

It means:
- `int_vector_main.c` does not see implementation deatils of `int_vector.c`
- It only sees what the header exposes
- All `#include` files have been copied in
- All macros expanded
- All `#ifdef` resolved

So:
```c
#include "int_vector.h"
#include <stdio.h>
```

After preprocessing becomes:
```
[ contents of int_vector.h ]
[ contents of stdio.h ]
[ rest of int_vector_main.c ]
```


> The Translation Unit is **not** the same as a `.o` object file.
> But they are directly related.

---

## What is a `.o` file?

A `.o` file (object file) is:
> The compiled machine-code output of one translation unit.

So:
```
int_vector_main.c
   ↓
Preprocess → translation unit
   ↓
Compile → int_vector_main.o
```

So the relationship is:
```
.c file
   ↓
translation unit (expanded source)
   ↓
.o file (compiled machine code + symbol table)
```

**Key difference**
| Translation Unit | `.o` File |
|------------------|-----------|
| Expanded source code | Compiled machine code |
| Exists during compilation | Exists after compilation |
| Conceptual source unit | Binary artifact |

---

## What is a Symbol?

This is one of the most important concepts in systems programming.

A **symbol** is:
> A **named entity** that the *linker* can resolve.

Symbols represent:
- Functions
- Global variables
- Static data (internal symbols)

**Example**
```c
int vec_init(IntVector *v, size_t cap);
```

When compiled, the object file contains a symbol entry:
```
vec_init
```

It includes:
- Symbol name
- Memory address (relative)
- Linkage type
- Visibility
- Section (text, data, etc.)

#### Types of Symbols

- **Defined symbol**

Defined in this object file:
```
vec_init
```

- **Undefined symbol**

Referenced but not defined here:
```
printf
```

The linker must resolve undefined symbols.

#### Where are symbols stored?

Inside the `.o` file in the **symbols table**.

We can inspect them with:
```bash
nm int_vector_main.o
nm int_vector.o
```

This will show:
- T → text (function)
- U → undefined
- B/D → global data
- etc.

#### Why Symbols matter?

When linking:
- The linker matches undefined symbols with the defined ones.
- If no match → undefined reference error.
- If multiple matches → multiple definition error.

Symbols are how C files talk to each other.

---

## What the Compiler Produces

The compiler produces:
- Machine code
- Symbol table

Symbols include:
- Functions
- Global variables

Example:

`int_vector.o` exports:
```
vec_init
vec_destroy
vec_push
vec_reserve
```

If they are not `static`.

---

## What is the Linker?

The linker:
- Takes multiple `.o` files
- Resolves symbols
- Connects function calls
- Produces one executable

---

## Symbol Resolution

Example:

In `int_vector_main.c`:
```c
vec_init(&v, 4);
```

The compiler says:
> I assume a function named `vec_init` exists somewhere.

Later, the linker:
- Searches object files
- Finds `vec_inti` in `int_vector.c`
- Connects the call

---

## What Causes "Undefined Reference"?

If we compile only:
```bash
clang int_vector_main.c -o app
```

But forget `int_vector.c`, the linker cannot find:
```
vec_init
vec_push
vec_destroy
```

We'll get:
```
undefined reference to 'vec_init`
```

This is not a compiler error.
It's a **linker error**.

---

## What Causes "Multiple Definition"?

If we define a function in a header:
```c
// BAD in header
int helper(void) {
    return 42;
}
```

And include the header in multiple `.c` files:

Each translation unit gets its own copy.

The linker sees:
```
helper defined in int_vector_main.o
helper defined in int_vector.o
```

Error:
```
multiple definition of 'helper'
```

This is why:
> Function definitions should not go in headers.

---

## Linkage Types (Critical Concept)

Every symbol has linkage.

#### External linkage (default)

```c
int foo(void);
```

- Visible across translation units
- Linker connects it

#### Internal linkage (static)

```c
static int helper(void);
```

- Only visible inside this `.c`
- Not exported
- Linker does not see it outside

This is why `static` matters.

---

## Why Include Guards Matter Here

Without include guards:
- Struct definitions may appear twice
- Function prototypes may duplicate
- Compilation fails before linking

Guards protect at preprocessing level.

---

## Full Build Model

```
int_vector_main.c
   ↓
Preprocess
   ↓
Compile → int_vector_main.o

int_vector.c
   ↓
Preprocess
   ↓
Compile → int_vector.o

int_vector_main.o + int_vector.o
   ↓
Linker
   ↓
app (executable)
```

---

## Where does the Header File fit in the Build Model?

Headers are **not compiled directly**.

They are consumed during preprocessing.

#### Full Build Model (with Headers)

```
main.c
   ↓
Preprocessing:
   - expands #include "int_vector.h"
   - expands system headers
   ↓
Translation Unit (expanded source)
   ↓
Compilation
   ↓
main.o

int_vector.c
   ↓
Preprocessing:
   - expands #include "int_vector.h"
   ↓
Translation Unit
   ↓
Compilation
   ↓
int_vector.o

main.o + int_vector.o
   ↓
Linker
   ↓
Executable
```

#### Important Insight

The header file is:
- Not compiled independently
- Not linked
- Not turned into a `.o` file

It is simply **text inserted into translation units**.

#### WHy headers exist then?

Because they:
- Provide declarations
- Ensure type consistency
- Prevent mismatches between files
- Define public interfaces

They exist purely for compilation correctness.

---

## Why this Design is Powerful

This architecture allows:
- Separation compilation
- Large codebases
- Faster rebuilds
- Encapsulation
- Private implementation details

This is how:
- Operatin systems
- Game engines
- Trading systems
- Embedded firmware

are built.

---

## Most Importal Rule

> A **header** *declares*.  
> A **`.c` file** *defines*.  
> The **linker** *connects*.  

---

## Takeaway

> - Each `.c` file becomes one translation unit.  
> - Translation units are compiled independently.  
> - The linker connects symbols across cannot find a symbol.  
> - "Undefined reference" = linker cannot find a symbol.  
> - "Multiple definition" = symbol defined in more than one object file.  
> - `static` gives internal linkage (private to file).  
> - Headers declare; `.c` files define.  