# Module 4.6 – Include Guards

### Learning Goals

- Explain why **include guards** are necessary
- Understand what happens without them
- Correctly write include guards from scratch
- Understand how they work at the preprocessor level
- Recognize common mistakes
- Understand the difference between include guards and `#pragma once`

---

## The Core Problem

Remeber:
> `#include` is just textual substitution.

If we write:
```c
#include "int_vector.h"
#include "int_vector.h"
```

The preprocessor literally pastes the header **twice** into the *translation unit*.

If the header contains:
```c
typedef struct {
    int x;
} A;
```

It becomes:
```c
typedef struct { int x; } A;
typedef struct { int x; } A;
```

That causes:
```
error: redefinition of 'A'
```

---

## Why Headers often get Included Multiple Times

Even if we don't include it twice directly, it can happen indirectly:

```
main.c
  includes a.h
a.h
  includes b.h
main.c
  also includes b.h
```

Now `b.h` gets included twice.

This is extremely common in real projects.

Without guards → compilation breaks.

---

## How Include Guards Work

Standard pattern:
```c
#ifndef INT_VECTOR_H
#define INT_VECTOR_H

/* header content */

#endif
```

##### Step-by-step behavior:

**First time header is included:**
- `INT_VECTOR_H` is not defined
- `#idndef` passes
- `#define INT_VECTOR_H` defines it
- Header contents are included

**Second time header is included:**
- `INT_VECTOR_H` is already defined
- `#ifndef` fails
- Entire header is skipped

So the header contents are included **exactly once per translation unit**.

--

## Important Clarification


Include guards work:
> Per translation unit, **not** per program.

Each `.c` file is compiled independently.

> **Each translation unit may include the header once.**

That's fine.

---

## Naming Convention

Convention:
```
FILENAME_H
```

For example:
- `int_vector.h` → `INT_VECTOR_H`
- `buffer_utils.h` → `BUFFER_UTILS_H`

Rules:
- Uppercase
- Underscores
- Based on filename
- Must be unique in project

---

## Common Mistakes

❌ **Forgetting `#define`
```c
#ifndef INT_VECTOR_H
/* header content */
#endif
```

This does nothing useful.

---

❌ **Using name macro in multiple headers**

If two headers both use:
```c
#ifndef HEADER_H
```

One might block the other accidentally.

**Macro names** must be *unique*.

❌ **Putting function definitions in headers (without `static` inline)**

Guards prevent multiple inclusion within a translation unit.

They do NOT prevent multiple definitions across translation units.

That's a linker-level issue.

---

## What about `#pragma once`?

Modern compilers support:
```c
#pragma once
```

It achieves the same effect as *include guards*.

Advantages:
- Simpler
- Less error-prone

Disadvantages:
- Not part of ISO C standard
- Rare portability concerns

In professional portable C code, traditional include guards are still preferred.

---

## Why this matters architecturally?

Include guards enable:
- Safe dependency graphs
- Modular headers
- Scalable systems
- Multi-level includes

Without them:
- Large projects would not compile

---

## Controlled Experiment

1. Remove **include guards** from `int_vector.h`

2. Add in `int_vector_main.c`:
```c
#include "int_vector.h"
#include "int_vector.h"
```

3. Compile.

We should get redefinition errors.

Then restore guards.

```bash
In file included from int_vector_main.c:2:
./int_vector.h:10:3: error: typedef redefinition with different types ('struct IntVector' vs 'struct IntVector')
   10 | } IntVector;
      |   ^
int_vector_main.c:1:10: note: './int_vector.h' included multiple times, additional include site here
    1 | #include "int_vector.h"
      |          ^
int_vector_main.c:2:10: note: './int_vector.h' included multiple times, additional include site here
    2 | #include "int_vector.h"
      |          ^
1 error generated.
```

---

## Mental Model

Headers operate at the **preprocessor level**.

Guards prevent textual duplication.

Linkage errors are a different layer (linker level).

We now clearly distinguish:
- Preprocessing problems
- Compilation problems
- Linking problems

---

## Takeaway

> - `#include` performs textual substitution.  
> - Headers can be included multiplle times indirectly.  
> - Inlcude guards prevent multiple inclusion within a translation unit.  
> - Standard pattern:  

    #ifndef FILE_NAME_H
    #define FILE_NAME_H
    ...
    #endif

> - **Guard names** must be *unique per header*.  
> - Guards solve preprocessing duplication, not linker duplication.  