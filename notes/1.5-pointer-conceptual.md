# Module 1.5 - Pointers (Conceptual)

### Learning Goals
- Explain what a **pointer** is without referring to syntax
- Understand that a pointer is **just a value** whose meaning is "an address"
- Distinguis clearly between: **a variable**, **its value**, **its address**, adn **a pointer to that address**.
- Understand why a pointer is **valid** vs **invalid**, based on lifetime
- Use the debugger to inspect pointer values safely

---

## The key idea

> **A pointer is a variable whose value is an address.**


## Why pointers exist at all

We already know:
- Variables live somewhere in memory
- That "somewhere" has an address
- Addresses exist independently of variables

Now let's consider this question:
> How can a function refer to memory that belongs to *another* function?

Answer:
> By passing the **address** of that memory.

But an address must itself be:
- **stored**
- **passed**
- **returned**
- **compared**

> So addresses must be treated as **values**.  
> That value is called a **pointer**.


## First pointer

**c/fundamentals/pointers_1.c**
```c
#include <stdio.h>

int main(void) {
    int x = 42;

    int *p = &x;

    printf("x value: %d\n", x);
    printf("pointer p value: %p\n", (void *)p);

    return 0;
}
```

### What is happening conceptually

```c
int x = 42;
```
- Creates an integer
- Stores `42`somewhere in memory
- That memory location has an address

```c
int *p = &x;
```
- Creates a variable named `p`
- `p` stores **the address of `x`**
- `p` does **no** store `42`
- `p` stores *where* `42` lives

So now we have:
| Name | What it is | What it contains |
| --------- | --------- | --------- |
| x | int | `42` |
| &x | address | location of `x` |
| p | pointer | same address as `&x` |


## Pointer â‰  value

- **`x`** $\rightarrow$ the **value**
- **`&x`** $\rightarrow$ the **location**
- **`p`** $\rightarrow$ a **variable** that stores a *location*


---

## Dereferencing

We will often hear:
> "Deferencing a pointer""

Conceptually, this means:
> "Go to the memory location stored in the pointer, and access what's there".

In code, this is written as:
```c
*p
```

But for now, just to understand the idea:
- pointer $\rightarrow$ location
- dereference $\rightarrow$ value at that location

---

## Pointer validity (critial rule)

A pointer is **valid** if and only if:
- it points to memory that:
    - currently exists
    - still belongs to the same object

Example [safe]:
```c
int x = 10;
int *p = &x;
```

As long as `x` exists:
- `p` is **valid**

Example [dangerous]:

```c
int* bad(void) {
    int x = 42;
    return &x;
}
```

Why this is wrong:
- `x` lives in `bad`'s stack frame
- that frame is *destroyed* on return
- the returned pointer stores an **invalid address**

Using it is **undefined behavior**.

---

## Pointer variables are normal variables

This is subtle but important:
- Pointers:
    - have **types**
    - have **lifetimes**
    - live on the **stack** (for now)
    - can be **copied**
    - can be **passed to functions**

They are not "special".
They just store addresses.

---

## Takeaway

> A **pointer** is a **value**  
> That *value* is an **address**  
> Pointers don't "own" memory by default  
> Pointer *validity* depends on the **lifetime of the object it points**  
> **Returning** the **address of a local variable** is **invalid**

---

| Expression | Meaning | Type | Abstract rule |
| ---------- | ---------- | ---------- | ---------- |
| `x` | Value | `int` | T |
| `&x` | Address where `x` lives | `int *` | T * |
| `p` | Value of the pointer (store an address, equal to `&x`) | `int *` | T * |
| `*p` | Value stored at that address held in `p` | `int` | T |
| `&p` | Address where the pointer variable `p` lives | `int **` | T ** |

---

### Extra

#### 1. Why must a pointer be declared as `int *p`?

Why `int p = &x;` is **NOT allowed**

Because `p` and `*p` are **different types**, and C is very strict about types.

- `x` is an `int`
- `&x` is an address
- An address has a **`pointer` type**, not an integer type

The correct declaration:
```c
int *p = &x;
```

This says:
- `p` is a variable
- its type is: "pointer to int"
- its value is the address of an `int`

Now the types match:
- `&x` $\rightarrow$ `int *`
- `p` $\rightarrow$ `int *`


#### Important rule

> **The type of a pointer encodes the type of the object it points to.**

So:
- `int *` $\rightarrow$ pointer to `int`
- `double *` $\rightarrow$ pointer to `double`
- `char *` $\rightarrow$ pointer to `char`

> "`p` is a variable whose value is an address, and `*p` is an `int`"


#### 2. Why do we need (`void *`) when printing addresses?

This is about `printf` and type safety, not pointers themselves.

```c
(void *)
```

- does **not** change the address
- does **not** change the bits
- does **not** change where it points

It only says:
> "Treat this address as a generic pointer for printing."

`void *` means:
> "Pointer to memory of unknown type."

It is used when:
- we only care about the address
- not about what's stored there