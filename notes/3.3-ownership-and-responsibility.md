# Module 3.3 – Ownershipd and Responsibility

### Learning Goals
- Define **ownership** precisely in the context of heap memory
- Identify who is responsible for freeing dynamically allocated memory
- Understand ownership **transfer**
- Design functions with clear ownership semantics
- Recognize ambiguous ownerhsip (a major source of bugs)
- Explain why "who frees?" is more important than "how to free?"

---

## What ownership means

> **Ownership is the responsibility to eventually free a piece of memory.**

If we own *heap memory*:
- we must ensure it is freed exactly once
- we must not free it too early
- we must not forget to free it

Ownership is **not**:
- having a pointer to memory
- being able to access memory
- being able to modify memory

We can have access **without ownership**.

---

## The fundamental rule

> **Whoever allocates memory is responsible for freeing it – unless ownership is explicitly transferred.**

This single rule explains:
- leaks
- double frees
- dangling pointers
- API design

---

## Simple ownership example

```c
void f(void) {
    int *p = malloc(sizeof(int));
    *p = 42;
    free(p);
}
```

Ownership is clear:
- `f` allocates
- `f` frees
- no ambiguity
- no bug

---

## Ownership transfer

Ownership can be transferred.

Example:
```c
int *make(void) {
    int *p = malloc(sizeof(int));
    return p;  // ownership transferred to caller
}
```

Caller becomes responsible:
```c
int *x = make();
/* use x */
free(x);
```

This is valid **only if**:
- ownerhsip transfer is *intentional*
- clearly documented
- consistently respected

---

## The most common ownership bug

```c
int *make(void) {
    int *p = malloc(sizeof(int));
    return p;
}

void use(void) {
    int *x = make();
    // forgot to free(x)
}
```

==This is a **memory leak**.==

The bug is not technical – it's **conceptual**.
- ownership was transferred
- responsibility was ignored

---

## Shared access ≠ shared ownership

Multiple pointers can refer to the same memory:

```c
int *p = malloc(sizeof(int));
int *q = p;
```

Important:
- there is still **only one owner**
- `free(p)` and `free(q)` is **double free**
- ownership is not duplicated by copying pointers

---

## What functions must communicate

Every function dealing with *heap memory* must answer:

| Question | Why it matters |
|----------|----------------|
| Does this function allocate? | Who must free? |
| Does it take ownership? | Is caller still responsible? |
| Does it borrow memory? | Is lifetime guaranteed? |
| Does it return ownership? | Must caller free? |

If these answers are unclear $\rightarrow$ bugs are guaranteed.

---

## Borrowing vs owning

==> **Borrowed memory:** we may use it, but not free it==   
==> **Owned memory:** we must free it eventually==

Example:
```c
void print(const char *s) {
    printf("%s\n", s);
}
```

- `print` borrows `s`
- caller owns `s`
- `print` must not free `s`

---

## A dangerous ambiguous API

```c
char *get_name(void);
```

Questions:
- Does caller free the result?
- Is it static?
- Is it heap allocated?

This API is **dangerous** unless documented.

Good APIs make ownership explicit.

---

## Ownership rules we must enforce

- Every `malloc` must have exactly one matching `free`
- Ownership must be transferred deliberately
- Borrowers must **never** `free`
- Owners must **eventually** `free`
- If ownership is unclear, the API is broken

---

## Takeaway

> **Ownership** means *responsibility* to **free memory**.  
> Allocating memory creates ownership.  
> Ownerhsip can be **transferred**, but only *explicitly*.  
> Multiple pointers do not imply multiple owners.  
> Borrowing memory does not grant ownership.  
> Ambiguous ownership leads to leaks and crashes.  
> Clear ownerhsip rules are more important than syntax. 