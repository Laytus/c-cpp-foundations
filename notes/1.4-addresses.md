# Module 1.4 - Addresses
(What memory is)


### Learning Goals
- Explain what an **address** is in the context of a running C program
- Distinguish clearly between a **value** and the **location** where it is stored
- Understand that **every variable must have an address**
- Explain why stack variables live **close together in memory**
- Understand that an address is **valid only during the object's lifetime**
- Explain (conceptually) why returning the location of a local variable is incorrect


## The key idea

> **Every variable in a running C program lives somewhere in memory.**

> **That "somewhere" is called its address.**

An address is:
- not a variable
- not a pointer
- not syntax

> It is simply: **a location in the program's memory**.


## Why addresses must exist

- A *program* runs as a **process**
- The *process* has a **stack**
- **Local variables** live on the *stack*

For the CPU to:
- load a value
- store a value
- pass a value to a function

It must kwow **where** that value is $\rightarrow$ **address**

---

So this:
```c
int x = 42;
```

implicitly means:
> "Reserve space somewhere in memory, and put the value 42 there."

> We don't control the address – the system does – but it **must exist**.

---

## Observing adresses

**c/fundamentals/addresses_1.c**
```c
#include <stdio.h>

int main(void) {
    int a = 10;
    int b = 20;
    int c = 30;

    printf("a value: %d\n", a);
    printf("b value: %d\n", b);
    printf("c value: %d\n", c);

    return 0;
}
```

Notice:
- `a`, `b`, `c`are next to each other
- they were declared together
- they live in the same stack frame

---

What matters:
- Each variable has a **distinct address**
- The addresses are **close together**
- They appear in a **regular pattern**

> This is the **stack frame** in memory.

> A **stack fram** is a **contiguous region of memory**.

> An **object's address** does **not change** during its **lifetime**.

When the function returns:
- the *addresses* become **invalid**
- the *memory* may be **reused**

---

## Address ≠ value (crucial distinction)

- **Value** $\rigtharrow$ what the variable contains $(10, 20, 30)$
- **Address** $\rigtharrow$ where that value is stored in memory

> Value and address are not interchangeable.

This is why C distinguishes:
- **data**
- **location**


## Stack frames revisited (with addresses)

Recall from 1.2:
```
foo frame
bar frame
main frame
```

Now reinterpret it as:
```
Higher addresses
+------------------+
| foo variables    |
+------------------+
| bar variables    |
+------------------+
| main variables   |
+------------------+
Lower addresses
```

**Stack frames**:
- are *regions of memory*
- have *real addresses*
- *appear and disappear* as *functions* are *called/returned*


## The critical rule

> When a **stack frame** is **destroyed**, **all addresses inside it** become **invalid**

==Not "set to zero".==
==Not "freed".==
==Simpy **invalid**.==

This is why returning the "location" of a local variable is ==wrong== – even before knowing pointer syntax.

---

## Takeaway

> Every *variable* has an **address**  
> Addresses are **locations in memory**  
> **Stack variables live close together**  
> Addresses are **stable** during **lifetime**  
> *Addresses* become **invalid** when the *stack frame ends*  

---

### What does it mean to "invalidate an address"?

First: what an address represents
- This is a location in memory where an object currently lives.

As long as:
- the object exists
- the memory is reserved for it

the address is valid.

#### What invalidation is not

invalidating an address does not mean:
- the memnory is ~~erased~~
- the bits become ~~zero~~
- the value ~~disappears~~
- the program ~~crashes automatically~~

Memory does not "self-destructu".

#### What invalidation does mean

> **The program is no longer allow to treat that memory location as the same object.**

The rules gave meaning to that address no longer apply.


### Why this matters?

If some part of the program *pretends* that address is still valid, it is:
- referring to memory that no longer belongs to that object
- violating the language's rules
- triggering **undefined behavior**

Even if:
- the value "looks right"
- the program doesn't crash
- the debugger shows something sensible

The rules have already been broken.

---

> **An address is valid only while the object it refers to exists.**

> **When the object's lifetime ends, its address becomes invalid, even if the memory still contains data.**