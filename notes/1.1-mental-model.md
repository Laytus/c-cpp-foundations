# Week 1 - Day 1

## From source code to running program (the real pipeline)
```
source code (.c)
   ↓ compiler (clang)
executable file
   ↓ operating system
process (running program)
```

Key idea:
> **The C program does not "run".**
> **The OS creates a process and starts executing your code.**


## What the OS gives the program at startup

When the OS launches your executable, it sets up:
- A **virtual address space**
- A **stack**
- A **heap** (initially empty)
- A **program entry point**

The control eventually reaches `main`.

Important:
- `main` is **not** the first thing that runs
- It is the **first thing we control**


## Program exit codes (why return 0 matters)

When `main`returns:
- The OS:
    - destroys the process
    - reclaims all memory
    - receives the return value

Convention:
> 0 → success
> non-zero → error


## Memory layout (high-level, no details)

When the program is running, memory is *conceptually* organized like this:

```
+------------------+  High addresses
|      Stack       |  ← local variables, function calls
+------------------+
|                  |
|      Heap        |  ← dynamic memory (later)
|                  |
+------------------+
| Static / Global  |  ← globals, static variables
+------------------+
|     Code         |  ← compiled instructions
+------------------+  Low addresses
```

---

## First example

**c/fundamentals/program_start.c**
```c
#include <stdio.h>

int main(void) {
    int x = 42;
    printf("X = %d\n, x");
    return 0;
}
```

What happens conceptually:
1. OS creates the process
2. **Stack** is initialized
3. **`main`** is called
4. `x`is created **on the stack**
5. `printf` is called
6. `main` returns
7. Process exits
8. **Stack** disappears


## VERY IMPORTANT: *lifetime intuition*

`x` exists only during steps 4-6.

After `main` returns:
- `x` no longer exists
- its memory is invalid
- the stack is gone


---

## Exercise 1

```c
#include <stdio.h>

int main(void) {
    int a = 10;
    int b = 20;
    int c = a + b;
    printf("%d\n", c);
    return 0;
}
```

1. How many stack variables exist at the same time?
**R:** 3 variables.
**S:** ==3 variables: `a`, `b` and `c`.== All three are **local variables of `main`**, so they coexist on the stack while `main` is executing.

2. In what order are they created?
**R:** First `a`, then `b` and finally `c`.
**S:** ==In source order (conceptually): `a` → `b` → `c`.==
Important nuances:
- The **compiler may reorder things internally**, but the *language-level lifetime* is as above.
- For reasoning and correctness, we should assume creation follows declaration order within the scope. 

3. When does each variable stop existing?
**R:** When `main` returns.
**S:** ==All three variables stop existing **at the same time**:==
- ==When `main` returns.==
- ==When the stack frame for `main` is **destroyed.==

4. Is there any heap memory involved?
**R:** No, only the Stack memory is involved.
**S:** ==No.==
- ==`a`, `b` and `c` are automatic variables → **stack**==
- ==`printf` may use internal buffers, but **the program does not explicitly allocate heap memory**==

---

## Exercise 2

```c
int main(void) {
    return 0;
}
```

1. Does this program allocate a stack?
**R:** Yes.
**S:** ==Yes. Even though there are no local variables.==
> A stack is required for:
> - function calls
> - return addresses
> - calling conventions

> A program **cannot run without a stack**.

2. Does it allocate a heap?
**R:** Yes.
**S:** ==Conceptually: **yes, but unused**.==
More precisely:
- ==The process has a **heap region available**.==
- ==But **no heap memory is allocated or used**.==

3. Does it still create a process?
**R:** Yes.
**S:** ==Yes. Absolutely.==
> No process → no program execution.

---

## Key mental models to keep

**Model 1 - Process vs code**
> Code does nothing by itself.
> The OS runs code inside a process.

**Model 2 - Stack is mandatory**
> Every running C program has a stack,
> even if you never declare a variable.

**Model 3 - Heap is optional**
> Heap memory exists conceptually,
> but is only used if you excplicitly allocate it.

---

**Day 1 takeaway**:
> **A C program is a process with a stack.**
> **Local variables live on that stack and die when their scope ends.**

---

When a function is called:
- A new stack frame is created
- The memory for that frame is **not zeroed**.
- It may contain leftovers from:
    - previous function calls
    - previous stack frames
    - previous programs


#### Declaration ≠ initialization

From the compiler's perspective:
- Space for **all local variables** in `main`
- is reserved when the stack frame is created

#### Very important rule
> **Reading an uninitialized local variable is undefined behavior.**