# Module 3.4 – `free` (Releasing Memory)

### Learning Goals

- Explain what `free` does and what it does *not* do
- Know exactly **when** it is safe to call `free`
- Understand what happens to memory **after** it is freed
- Recognize invalid uses of `free`
- Understand why freed memory must never be accessed again
- Use tools to detect incorrect `free` usage

---

## What `free` is

Prototype:
```c
void free(void *ptr);
```

What `free` does:
- Releases previously allocated *heap memory* 
- Makes the memory available for reuse by the allocator

What `free` does **not** do:
- It does not erase memory
- It does not set the pointer to `NULL`
- It does not protect us from using the pointer again
- It does not know how many bytes were allocated

---

## The fundamental rule of `free`

> **We must call `free` exactly once for every successful `malloc`.**

Not:
- zero times $\rightarrow$ memory leak
- more than once $\rightarrow$ undefined behavior

Exactly once.

---

## What happens after `free`

After:
```c
free(p);
```

- The memory is **no longer ours**
- The pointer `p` still holds the same address
- That address is now **invalid to access**

This creates a **dangling pointer**.

```c
free(p);
*p = 10;   // ❌ undefined behavior
```

Even reading is illegal.

---

## Why memory is not noticed as "freed" 

The allocator does **not**:
- clear the memory
- overwrite it with zeros
- change the pointer value

So this code may appear to "work":
```c
free(p);
printf("%d\n", *p);   // ❌ UB, may print old value
```

This illusion is what makes *heap bugs* dangerous.

---

## Always invalidate pointers after `free`

Best practice:
```c
free(p);
p = NULL;
```

Why?
- `NULL` is a known invalid address
- Dereferencing `NULL` crashes immediately
- Easier to debug than silent corruption

Rule:
> **After freeing, set owned pointers to `NULL`.**

---

## Invalid uses of `free` (all UB)

❌ **Freeing stack memory**
```c
int x;
free(&x);   // ❌ UB
```

Only *heap memory* from `malloc`/`calloc`/`realloc` may be freed.

❌ **Freeing memory twice (*double free*)**
```c
free(p);
free(p);   // ❌ UB
```

This corrupts the allocator's internal state.

❌ **Freeing uninitialized or random pointers**
```c
int *p;
free(p);   // ❌ UB
```

`p` does not point to valid *heap memory*.

❌ **Freeing memory we do not own**
```c
void f(int *p) {
    free(p);   // ❌ unless ownership was transferred
}
```

Borrowers must never free.

---

## Freeing `NULL` (special case)

This is safe:
```c
free(NULL);
```

It does nothing.

This allows patterns like:
```c
free(p);
p = NULL;
free(p);   // safe, no-op
```

Still, avoid relying on this casually.

---

## Typical correct pattern

```c
int *p = malloc(sizeof(int));
if (!p) {
    // handle failure
}

/* use p */

free(p);
p = NULL;
```

This pattern is:
- safe
- debuggable
- professional

---

## Debugging incorrect `free`

With **AddressSanitizer** (recommended)

Compile with:
```bash
-fsanitize=address,undefined
```

ASan detects:
- `double free`
- `invalid free`
- `use-after-free`

Typical message:
```
ERROR: AddressSanitizer: heap-use-after-free
```

**With debugger (limited)**

We can:
- inspect pointer values
- see when memory is reused

But the debugger cannot enforce legality.

---

## Takeaway

> `free` releases *heap memory* back to the allocator.  
> Every successful allocation must be *freed exactly once*.  
> After `free`, the memory must never be accessed again.  
> `free` does not clear memory or change pointer values.  
> Freed pointers become **dangling pointers**.  
> Only *heap memory* may be freed.  
> Setting pointers to `NULL` after `free` improves safety.  