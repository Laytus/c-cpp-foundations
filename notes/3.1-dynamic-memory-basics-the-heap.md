# Module 3.1 – Dynamic Memory Basics (the Heap)

### Learning Goals
- Explain what **dynamic memory**
- Distinguish clearly between **stack** and **heap**
- Understand **why** the heap exists
- Predict when stack memory is insufficient
- Explain how heap memory relates to **lifetime** and **ownership**
- Recognize which problems dynamic memory is meant to solve

---

## Two major kinds of memory in C

At a high level, C programs use two main memory regions:

| Region | Purpose |
|--------|---------|
| Stack  | Automatic, short-lived storage |
| Heap   | Manual, long-lived storage |

We've already been working with the **stack**.
Now we introduce the **heap**.

---

## The stack

**Stack memory** is:
- Automatically allocated
- Automatically freed
- Tied to **scope and function calls**
- Fasr and structured

Example:
```c
void f(void) {
    int x = 10;
}
```

- `x` is allocated when `f` is entered
- `x` is destroyed when `f` returns
- We do **not** control its lifetime

**Key limitation**

> Stack memory **cannot outlive the function** that created it.

This is a **hard rule**.

---

## Why the stack is not enough

There are many legitimate cases where stack memory fails:

#### 1. Returning memory from a function

```c
int* main(void) {
    int x = 42;
    return &x;  // ❌ invalid
}
```

We've already seen this fail due to lifetime.

#### 2. Data whose size is only known at runtime

```c
int n;
scanf("%d", &n);
int arr[n];  // sometimes illegal, sometimes unsafe
```

This may:
- overflow the stack
- be unsupported
- be non-portable

#### 3. Long-lived data

Examples:
- buffers reused across function calls
- data structures shared across modules
- results that must persist after a function returns

The stack cannot support this safely.

---

## Enter the heap

> **The heap is a region of memory not tied to function scope.**

Heap memory:
- Is **allocated explicitly**
- Is **freed explicitly**
- Exists **until we  free it**
- Has no automatic lifetime

This is both powerful and dangerous.

---

## Heap lifetime

Once allocated on the heap:
- Memory exists **independently of any function**
- It remains **valid across function calls**
- It remains **valid across scopes**
- It remains **valid until free is called**

This directly solves the stack limitations.

---

## Heap vs Stack – precise comparison

| Aspect | Stack | Heap |
|--------|-------|------|
| Allocation | Automatic | Manual |
| Deallocation | Automatic | Manual |
| Lifetime | Scope-based | Explicit |
| Size | Limited | Large |
| Speed | Very fast | Slower |
| Safety | High | Low (if misused) |
| Ownership | Implicit | Explicit |

---

## Ownership begins here

With leap memory:
- The compiler no longer helps us
- The language no longer tracks lifetime
- We are responsible

This introduces:
- ownership
- responsability
- discipline

Every **heap allocation** must have:
- a **clear owner**
- a **clear deallocation point**

---

## Mental model

> **Stack** memory is *borrowed*.
> **Heap** memory is *owned*.

*Borrowed* memory is **reclaimed automatically**.
*Owned* memory is **returned manually**.

---

## Takeaway

> **Stack memory** is *automatic* and *scope-bound*.  
> **Heap memory** is *manual* and *scope-independent*.  
> Stack memory **cannot** outlive the function that creates it.  
> Heap memory exists **until explicitly freed**.  
> **Dynamic memory** solves *lifetime* and *size limitations* of the stack.  
> Using the heap introduces *ownership* and *responsability*.