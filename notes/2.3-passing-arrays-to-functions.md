# Module 2.3 – Passing Arrays to Functions

### Learning Goals
- Explain **how arrays are passed to functions in C**
- Understand why **array size information is lost**
- Recognize the **syntactic illusion** of array parameters
- Correctly design functions that operate on arrays
- Explain why array size must be passed explicitly
- Avoid the most common array-related bugs in C APIs

---

## The uncomfortable truth

> **We cannot pass an array by value in C.**

Whenever we "pass an array" to a funciton, what actually happens is:

> **A pointer to the first element is passed.**

---

## The syntactic illusion

Let's consider this function:
```c
void print_array(int arr[]) {
    printf("%d\n", arr[0]);
}
```

This **looks like**:
- `arr` is an array parameter

But it is **actually** equivalent to:
```c
void print_array(int *arr) {
    printf("%d\n", arr[0]);
}
```

There is **no difference**.

This is mandated by the C standard.

---

## Demonstrating the loss of size information

**c/fundamentals/arrays_function_1.c**
```c
#include <stdio.h>

void f(int arr[]) {
    printf("sizeof(arr) = %zu\n", sizeof(arr));
}

int main(void) {
    int a[10];
    printf("sizeof(a)   = %zu\n", sizeof(a));
    f(a);
    return 0;
}
```

**Typical output (64-bit system)**:
```
sizeof(a)   = 40
sizeof(arr) = 8
```

**Why?**
- `a` is an array of 10 `ints` $\rightarrow$ $10 \times 4 = 40$ bytes
- `arr` is actually a pointer $\rightarrow$ 8 bytes

This proves:
> **Array size information is lost when passing arrays to functions.**

---

## Why C works this way

C makes a trade-off:
- Passing arrays by value would:
    - *copy large memory blocks*
    - *be expensive*
    - *complicate calling conventions*

Instead:
- *Only the address is passed*
- *Functions operate directly on the caller's memory*

This gives:
- *performance*
- *flexibility*
- *responsibility*

---

## The correct pattern: pass size explicitly

This is the **canonical C pattern**:
```c
void print_array(int *arr, size_t length) {
    for (size_t i = 0; i < length; i++) {
        printf("%d", arr[i]);
    }
    printf("\n");
}
```

Called as:
```c
int a[4] = {10, 20, 30, 40};
print_array(a, 4);
```

Here:
- `arr` $\rightarrow$ pointer to first element
- `length` $\rightarrow$ how many elements exist

This is how **almost all C APIs work**.

---

## Why `arr[i]` still works inside functions

Inside the function:
```c
arr[i]
```

is just:
```c
*(arr + i)
```

Because:
- `arr` is a pointer
- Pointer arithmetic is scaled by `sizeof(type)`

So array syntax still works even though `arr` is not an array.

---

## Common incorrect approaches

❌ **Using `sizeof` inside the function
```c
void f(int arr[]) {
    size_t n = sizeof(arr) / sizeof(arr[0]);
}
```

**This never works.**

❌ **Assuming a fized size**
```c
void f(int arr[10]) { }
```

This does **not** enforce size.
It is still just:
```c
void f(int *arr) { }
```

**The `10` is ignored by the compiler.**

---

## Takeaway
> **Arrays cannot be passed by value in C.**  
> When passed to a function, an array *decays* to a *pointer* to its *first element*.  
> **Size information** is *lost* during this *decay*.  
> Function parameters written as `type arr[]` are actually pointers.  
> The function must be told *how many elements exist*.  
> The correct pattern is: **pass a pointer and a length**.  
> Most C APIs follow this exact design.

---

