# Module 2.4 – Off-by-One Errors and Bounds

### Learning Goals
- Explain what an **off-by-one error** is
- Understand why **array bounds errors** are so dangerous in C
- Correctly reason about valid array indices
- Identify common **loop boundary mistakes**
- Predict what memory gets accessed when bounds are violated
- Use sanitizers and the debugger to detect these errors

---

## What "bounds" mean in C

Given:
```c
int arr[4];
```

Valid indices are:
```
0, 1, 2, 3
```

Invalid indices are:
```
-1, 4, 5, ...
```

**Fundamental rule**
> **Valid indices are 0 through size -1.**

---

## The classic off-by-one error

Let's consider this loop:
```c
for (int i = 0; i <= 4; i++) {
    arr[i] = i;
}
```

What's wrong?
- The loop runs **5 times**
- `arr[4]` is accessed
- `arr[4]` is **one past the end**

This is an **off-by-one error**.

---

## Why this is undefined behavior

Remember from earlier:
- Arrays are contiguous memory
- There is no bounds checking
- Writing past the end writes to **someone else's memory**

So:
```c
arr[4] = 42;
```

Does not fail safely.

It:
- corrputs adjacent memory
- may overwrite another variable
- may break later code
- may appear to work

Thi is **undefined behavior**.

---

## Correct loop structure

Given an array of length `n`:
```c
for (size_t i = 0; i < n; i++) {
    // safe access: arr[i]
}
```

**Why `< n` and not `<= n`?**

Because:
- last valid index is `n - 1`
- `i < n` stops at exactly the right moment

This is the **canonical C loop**.

---

## Off-by-one on the other side (negative indices)

This is also UB:
```c
arr[-1] = 10;
```

C does **not** stop you.

This writes *before* the array.

---

## Strings: the most common off-by-one bug

Example:
```c
char s[5] = "hello";   // ❌ wrong
```

Why?
- `"hello"` needs **6 bytes**:
    - 5 letters
    - 1 '`\0`'

Correct:
```c
char s[6] = "hello";
```

This single missing byte causes:
- missing terminator
- string functions reading past bounds
- classic vulnerabilities

---

## Detecting off-by-one errors

**With sanitizers (best tool)**

Compile with:
```bash
-fsanitize=address,undefined
```

Typical run:
```
heap-buffer-overflow
stack-buffer-overflow
```

This is **exactly** ehat **ASan** is for.

---

## The professional habit to build

> **Always think in terms of ranges, not counts.**

---

## Takeaway
> Arrays hace *strict bounds*: indices `0` to `size - 1`.  
> Accessing *outside bounds* causes *undefined  behavior*.  
> `i < size` is the correct loop condition.  
> C performs no bounds checking.  
> String bugs are often off-by-one errors involving `'\0'`.  
> Sanitizers are the best tool to catch bounds violations.  