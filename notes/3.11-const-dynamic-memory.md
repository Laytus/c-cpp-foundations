# Module 3.11 – Const + Dynamic Memory (Read-Only Ownership)

### Learning Goals
- Combine `const` with *heap-allocated memory* correctly
- Distinguish **ownership** from **mutability**
- Design functions that *borrow* heap memory safely
- Express read-only ownership in APIs
- Prevent accidental modification of dynamic memory
- Understand how this maps directly to C++ design

---

## Two orthogonal concepts (separate mentally)

Dynamic memory introduces **two independent axes**:

| Concept | Question |
|---------|----------|
| Ownership | Who must call `free`? |
| Mutability | Who may modify the data? |

`const` affects **mutability, not ownership**.

---

## `const` does NOT change ownership

```c
const int *p = malloc(sizeof(int));
```

Import facts:
- Memory is heap-allocated
- Someone must still call `free`
- `const` only restricts modification *through `p`*

This is valid:
```c
free((void *)p);
```

Ownership and mutability are separate responsibilities.

---

## Read-only borrowed heap memory (most common pattern)

```c
void print_array(const int *arr, size_t n);
```

Meaning:
- `print_array` **borrows** the array
- It cannot modify elements
- It must not free the memory
- Caller retains ownership

This is **professional-grade C API design**.

---

## Read-only ownership

Sometimes a function **owns** memory but promises not to modify it.

Example:
```c
struct Buffer {
    const char *data;
    size_t size;
}
```

Here:
- `Buffer` owns the memory
- Consumers can read but not write
- Only the owner may free

This expresses:
> "We can look, but not touch."

---

## Returning `const` heap memory

```c
const char *make_message(void) {
    char *p = malloc(6);
    strcpy(p, "hello");
    return p;
}
```

This means:
- Ownership is transferred
- Caller must free
- Caller may not modify contents

Usage:
```c
const char *msg = make_message();
/* read only */
free((void *)msg);
```

This pattern is common in C libraries.

---

## Why this prevents bugs

Using `const` with dynamic memory:
- Prevents accidental writes
- Documents API intent
- Allows compiler diagnostics
- Makes ownership clearer
- Prevents mutation-based corruption

This is **design-level safety**, not runtime safety.

---

## Common mistake: confusing `const` with lifetime

❌ Incorrect assumptions:
```c
const int *p = malloc(sizeof(int));
// memory is safe forever ❌
```

Reality:
- `const` does not extend lifetime
- `free(p)` still ends validity
- dangling pointers still exist

`const` ≠ lifetime management.

---

## `const` + `realloc` 

```c
const int *p = malloc(n * sizeof(int));
```

We **cannot** safely `realloc` through `p`.

Correct pattern:
```c
int *tmp = (int *)p;
tmp = realloc(tmp, new_n * sizeof(int));
p = tmp;
```

Rule:
> **Reallocation requires mutable ownership.**

Read-only views cannot resize memory.

---

## Takeaway

> - *Ownership* and *mutability* are *independent concepts*.  
> - `const` restricts modification, not lifetime.  
> - *Heap memory* can be owned but read-only.  
> - Borrowed heap memory should usually be `const`.  
> - `const` improves API clarity and safety.  
> - `const` does not prevent `use-after-free` or leaks.  
> - Reallocation requires mutable ownership.