# Module 3.6 â€“ Memory Leaks

### Learning Goals

- Define what a **memory leak** is
- Explain why leaks happen in C
- Understand why leaks are not "harmless"
- Recognize common leak patterns
- Reason about leaks using **ownership**
- Use tools to detect memory leaks
- Prevent leaks by construction

---

## What is a memory leak?

> A **memory leak** occurs when **heap memory** is **allocated but never freed**.

That memory:
- remains allocated
- cannot be reused
- is no longer reachable by the program

Ownership existed â€“ but was never properly ended.

---

## The simples leak

```c
void f(void) {
    int *p = malloc(sizeof(int));
    *p = 42;
    // forgot to free(p)
}
```

What happens:
- memory is allocated
- function exits
- pointer `p` is destroyed
- **memory remains allocated forever**

---

## Why leaks are subtle

Leaks:
- do not crash immediately
- do not trigger UB instantly
- do not show up in normal debugging
- accumulate over time

A program may:
- run fine for minutes
- slow down after hours
- crash after days

This makes leak **operational bugs**, not syntactic ones.

---

## "But the OS frees memory when the program exits!"

This is true â€“ **and irrelevant**.

Why leaks still matter:
- Long-running programs (servers, daemons)
- Embedded systems
- Libraries (we don't control program exit)
- Repeated allocations inside loops
- Tests that mask real problems

Also:
> Leaks often indicate **broken ownership logic**.

---

## The most common leak patterns

ðŸ”´ **Pattern 1 â€“ Early return**
```c
int make(int fail) {
    int *p = malloc(sizeof(int));
    if (fail) {
        return NULL;   // âŒ leak
    }
    return p;
}
```

Ownership was created but not resolved.

ðŸ”´ **Pattern 2 â€“ Overwriting the only pointer**
```c
int *p = malloc(sizeof(int));
p = malloc(sizeof(int));   // âŒ leaked first allocation
```

Once the pointer is overwritten, the memory is unreachable.

ðŸ”´ **Pattern 3 â€“ Forgetting ownership transfer**
```c
void process(void) {
    int *p = make();
    // forgot to free(p)
}
```

The callee transferred ownership â€“ the caller ignored it.

ðŸ”´ **Pattern 4 â€“ Multiple exit paths**
```c
int *p = malloc(sizeof(int));
if (error1) return;
if (error2) return;
// forgot free
```

This is extremely common in real code.

---

## Leaks vs dangling pointers

| Bug type | What goes wrong |
|----------|-----------------|
| `Use-after-free` | Memory freed too early |
| Dangling pointer | Pointer outlives memory |
| Memory leak | Memory outlives all pointers |

Leaks are the **inverse** of `use-after-free`.

---

## Ownership is the real solution

Most leaks are caused by:
- unclear ownership
- forgotten responsabilities
- missing `free` paths

If ownership is clear, leaks disappear.

Rule reminders:
> **Every `malloc` must have a matching `free` alogn all control paths.**

---

## Detecting memory leaks

**With AddressSanitizer**

Compile with:
```bash
-fsanitize=address
```

At program exit, ASan reports leaks:
```
ERROR: LeakSanitizer: detected memory leaks
```

This shows:
- where memory was allocated
- how many bytes leaked

*+With Valgrind (conceptual mention)**

**Valgrind**:
- tracks allocations
- reports definitely lost blocks
- slower but very precise

---

## Leak-safe exit point

**Pattern: single exit point**
```c
int *p = malloc(sizeof(int));
if (!p) return NULL;

/* use p */

free(p);
return result;
```

**Pattern: cleanup section**
```c
int *p = malloc(sizeof(int));
if (!p) goto cleanup;

/* use p */

cleanup:
    free(p);
```

This pattersn is common in C for correctness.

---

## The professional mindset shift

> **Memory leaks are logic bugs, not memory bugs.**

They reflect:
- broken ownership
- incomplete reasoning
- missing invariants

Tools find them â€“ design prevents them.

---

## Takeaway

> A **memory leak** occurs when allocated memory is **never freed**.  
> Leaks do not crash immediately but accumulate over time.  
> Leaks often arise from unclear ownership or early returns.  
> Every allocation must be freed along all code paths.  
> Leak detection tools report leaks at program exit.  
> Clear ownership rules prevent memory leaks.  