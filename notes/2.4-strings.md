# Module 2.4 – Strings (Null-Terminated Arrays)

### Learning Goals
- Explain what a **C string** really is in memory
- Understand the role of the **null terminator (`'\0'`)**
- Predict how string functions know where a string ends
- Explain why strings are passed as pointers
- Identify common string-related bugs
- Safely inspect strings with the debugger

---

## What a C string actually is

> A **C string** is an **array of char terminated by a null byte (`'\0'`)**.

Example:
```c
char s[] = "hello";
```

In memory, this is:
```c
'h' 'e' 'l' 'l' 'o' '\0'
```

That final `'\0'` is **mandatory**.

---

## Why the null terminator exists

C strings:
- do **not** store their length
- rely on a sentinel value to mark the end

The **sentinel** is:
```c
'\0'
```

String functions (`printf`, `strlen`, `strcpy`, etc.) work by:
> "Read characters until you see `'\0'`.

---

## Observing a string in memory

**c/fundamentals/strings_1.c**
```c
#include <stdio.h>

int main(void) {
    char s[] = "hi";

    printf("s    = %s\n", s);
    printf("s[0] = %p\n", (void *)&s[0]);
    printf("s[1] = %p\n", (void *)&s[1]);
    printf("s[2] = %p\n", (void *)&s[2]);
 
    return 0;
}
```

Output:
```
s    = hi
s[0] = 0x16fdfe880
s[1] = 0x16fdfe881
s[2] = 0x16fdfe882
```

Expected memory layout:
```
'h' 'i' '\0'
```

Addresses are contiguous, separated by `sizeof(char)` $\rightarrow$ **1 byte**.

---

## Strings decay to pointers (just like arrays)

When we write:
```c
printf("%s\n", s);
```

`s` decays to:
```c
&s[0]
```

Type:
```c
char *
```

"Although `printf` reads every element inside the `string` until `'\0'`.

So strings are passed as pointers everywhere.

---

## Why strings are dangerous

❌ **No bounds checking**
```c
char s[3] = "hi";
s[2] = 'X'; // overwrites '\0'
printf("%s\n", s); // underfined behavior
```

Now there is **no terminator**.

> **The function will keep reading memory until it *accidentally* finds `'\0'`.**

❌ **Missing space for `'\0'`**
```c
char s[2] = "hi"; // ❌ too small
```

We need **3 bytes**:
- `'h'`
- `'i'`
- `'\0'`

This is a classic bug.

---

## String literals vs characters arrays (important)

**String literal**
```c
char *p = "hello";
```

- Stored in **read-only memory**
- Must **NOT** be modified
- Lifetime: *entire program*

Writing to it is **undefined behavior**.

**Character array**
```c
char s[] = "hello";
```

- Stored in **writable memory**
- We can **modify characters**
- Size includes `'\0'`

These are **not the same**, even though they look similar.

---

## Strings and functions

Typical pattern:
```c
void print(const char *s) {
    printf("%s\n", s);
}
```

Why `const`?
- Function promises *not to modify* the string
- Accepts both *literals* and *arrays*
- Documents intent

---

## Takeaway
> A **C string** is an **array of `char`** terminated by **`'\0'`**.  
> The **null terminator** marks the *end of the string*.  
> C strings do **not** store their *length*.  
> String functions rely entirely on `'\0'`.  
> Strings *decay* to '`char *`' when passed to functions.  
> Writing past the terminator causes **undefined behavior**.  
> String **literals** must **not** be modified.  

---

### Why C strings are a convention, not a type

In C:
- `char *` $\rightarrow$ pointer to a character
- `char[]` $\rightarrow$ array of characters

A `string` is **not** a distinct type.

It is:
> **A convention: "characters until '`\0`'.**