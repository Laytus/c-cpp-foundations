# Module 3.9 – `calloc` (Zero-Initialized Memory)

### Learning Goals

- Explain what `calloc` does differently from `malloc`
- Know when `calloc` is preferable
- Understand what "zero-initialized" really means
- Avoid uninitialized-memory bugs
- Use `calloc` safely with arrays and structs
- Understand performance and semantic tradeoffs

---

## What `calloc` is

Prototype:
```c
void *calloc(size_t nmemb, size_t size);
```

`calloc`:
- allocated `nmemb * size` bytes
- initializes **all bits to zero**
- returns `NULL` on failure
- returns `void *`

---

## `calloc` vs `malloc` 

| Aspect | `malloc` | `calloc` |
|--------|----------|----------|
| Initialization | Uninitialized | Zero-initialized | 
| Parameters | total bytes | count x size | 
| Performance | Slightly faster | Slightly slower | 
| Safety | Lower | Higher | 

Important:

> Zero-initialized ≠ "safer forever", but it **prevents UB at first use**.

---

## What "zero-initialized" really means

`calloc` sets **every byte to zero**.

This implies:

| Type | Initial value |
|------|---------------|
| `int`, `long`, `size_t` | 0 |
| `float`, `double` | 0.0 |
| pointers | `NULL` |
| `char` | `\0` |
| `struct` | all fields zeroed |

This is **guaranteed by the C standard**.

---

## Example: safe dynamic array

```c
size_t n = 10;
int *arr = calloc(n, sizeof(int));
if (!arr) {
    // handle failure
}
```

Now:
- `arr[i] == 0` for all `i`
- no uninitialized reads
- safer default state

---

## Example: `struct` allocation

```c
struct Point {
    int x;
    int y;
};

struct Point *p = calloc(1, sizeof(struct Point));
```

Equivalent to:
```c
p->x = 0;
p->y = 0;
```

Without needing to manually initialize.

--

## When should we use `calloc`?

We use `calloc` when:
- We need a known initial state
- We will gradually fill data
- We want `NULL` pointers by default
- We want to avoid UB during early reads
- We are initializing arrays or structs

---

## When `calloc` is not ideal

Avoid `calloc` when:
- We will immediately overwrite all values
- Performance is critical in hot loops
- Zero-initialization has no semantic meaning

In those cases, `malloc` + manual init is fine.

---

## Ownership and `calloc`

Ownerhsip rules are **identical** to `malloc`:
- Caller owns the memory
- Must free exactly once
- `free` is still required
```c
free(arr);
arr = NULL;
```

---

## `calloc` does NOT prevent logic bugs

Important:

`calloc` does NOT:
- prevent `out-of-bounds` access
- extend lifetime
- prevent leaks
- make ownership automatic

It only prevents **uninitialized-memory UB**.

---

## Takeaway

> - `calloc` allocates and **zero-initializes** *heap memory*.  
> - All bits are set to zero by the allocator.  
> - Zero-initialization prevents uninitialized-read UB.  
> - `calloc(n, sizeof(T))` is ideal for **arrays** and **structs**.  
> - Ownership and `free` rules are identical to `malloc`.  
> - `calloc` trades a small performance cost for safety.  