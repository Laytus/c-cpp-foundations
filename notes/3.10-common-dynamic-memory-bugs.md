# Module 3.10 – Common Dynamic Memory Bugs (and How to Debug Them)

### Learning Goals

- Recognize the most common dynamic memory bugs in C
- Classify bugs by **ownership**, **lifetime**, or **bounds**
- Understand why many bugs appear far from their cause
- Read sanitizer reports and connect them to code
- Apply systematic debugging strategies
- Prevent bugs by construction not by luck

---

## The Big Picture: Almost all heap bugs fall into 5 categories

| Category | Root cause |
|----------|------------|
| Memory leak | Ownership not ended |
| `Use-after-free` | Lifetime ended too early |
| Double free | Ownership duplicated |
| Invalid free | Freeing non-heap memory |
| `Out-of-bounds` | Indexing past allocation |

---

## Bug #1 – Memory Leak

Example
```c
int *p = malloc(sizeof(int));
if (!p) return;
// forgot free(p)
```

**Symptons**
- Program works
- Memory usage grows
- LeakSanitizer reports leaks at exit

**Root cause**
- Ownership created, never released

**Fix**
- Ensure every allocation has a matching `free`
- Cover **all control paths**

---

## Bug #2 – `Use-After-Free`

**Example**
```c
int *p = malloc(sizeof(int));
free(p);
*p = 10;   // ❌
```

**Symptons**
- Random crashes
- Data corruption
- Works "sometimes"

**Root cause**
- Access after lifetime ended

**Fix**
- Never access freed memory
- Set pointers to `NULL`
- Minimize aliasing

---

## Bug #3 – Double Free

**Example**
```c
free(p);
free(p);   // ❌
```

Or via aliases:
```c
int *a = p;
free(p);
free(a);   // ❌
```

**Symptons**
- Immediate crash
- Heap corruption
- ASan: "double free"

**Root cause**
- Ownership freed more than once

**Fix**
- Single owner rule
- Clear ownership transfer
- Null pointers after free

---

## Bug #4 – Invalid Free

**Example**
```c
int x;
free(&x);   // ❌
```

Or:
```c
int *p;
free(p);   // ❌ uninitialized
```

**Symptons**
- Immediate crash
- Allocator panic

**Root cause**
- Freeing memory not allocated by allocator

**Fix**
- Only free pointers returned by `malloc`/`calloc`/`realloc`
- Initialize pointers

---

## Bug #5 – `Out-of-Bounds` Access

**Example**
```c
int *arr = malloc(5 * sizeof(int));
arr[5] = 10;   // ❌
```

**Symptons**
- Silent corruption
- Random crashes later
- ASan: heap-buffer-overflow

**Root cause**
- Indexing beyond allocated size

**Fix**
- Track array size explicitly
- Validate indices
- Avoid magic numbers

---

## The Most Dangerous Bugs (combined failures)

**Example: `realloc` + alias + UAF**
```c
int *a = malloc(5 * sizeof(int));
int *b = a;

a = realloc(a, 10 * sizeof(int));
b[0] = 1;   // ❌ maybe UAF
```

This is:
- `realloc` alias bug
- `use-after-free`
- nondeterministic

These are the hardest to debug manually.

---

## How AddressSanitizer helps (and why we must use it)

ASan detects:
- `use-after-free`
- double free
- invalid free
- heap buffer overflow
- memory leaks

Example output:
```
ERROR: AddressSanitizer: heap-use-after-free
```

ASan gives:
- exact line of invalid access
- allocation site
- free site

This collapses debugging time from hours to minutes.

---

## Systematic Debugging Strategy

When we see a *heap bug*:
1. Identify **what kind** of bug it is
2. Find the **allocation**
3. Find the **`free`**
4. Check **ownership assumptions**
5. Look for **aliases**
6. Check **bounds**

---

## Preventing bugs by construction

The safest code has these properties:
- Clear ownership rules
- One owner per allocation
- Minimal aliasing
- Explicit sizes
- Single exit cleanup
- Sanitizers enabled always

---

## Takeaway

> - Most heap bugs fall into a small number of categories.  
> - **Memory leaks** are *ownership bugs*.  
> - `Use-after-free` is a *lifetime bug*.  
> - **Double free** is *duplicated ownership*.  
> - **Invalid free** means *freeing non-heap memory*.  
> - `Out-of-bounds` access *corrupts unrelated memory*.  
> - Sanitizers are essential for detecting heap bugs.  
> - Clear ownership and lifetime rules prevent most errors.  
