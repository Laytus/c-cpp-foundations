# Module 4.3 – Initialization and Destruction Patterns

### Learning Goals
- Design structs with clear initialization rules
- Separate **construction** from raw memory allocation
- Implement `init`/`destroy` patterns correctly
- Mantain invariants throughout a struct's lifetime
- Avoid leaks and partial-initialization bugs
- Understand how this maps directly to C++ constructors/destructors

---

## The Core Problem

In C, we can do this:
```c
struct Buffer b;
```

But this does **not guarantee**:
- `b.data` is valid
- `b.size` is correct
- `b.capacity` makes sense

Raw allocation ≠ valid object.

We must create **controlled initialization**.

---

## The Fundamental Pattern

Every non-trivial struct should have:
```
Type_init(...)
Type_destroy(...)
```

This enforces:
- lifetime control
- invariants enforcement
- ownership clarity

---

## Example: A Dynamic Buffer

Let's design something realistic:
```c
struct Buffer {
    char *data;
    size_t size;
    size_t capacity;
};
```

**Invariants we want:**
- `data` == `NULL` if `capacity` == 0
- `size` <= `capacity`
- data points to valid heap memory if not `NUL`

The compiler will not enforce this. We must.

---

## Initialization Pattern (Stack-Allocated Struct)

```c
int buffer_init(struct Buffer *b, size_t capacity) {
    b->data = malloc(capacity);
    if (!b->data) {
        b->size = 0;
        b->capacity = 0;
        return -1;
    }

    b->size = 0;
    b->capacity = capacity;
    return 0;
}
```

Important characteristics:
- Caller owns `struct Buffer`
- Function initializes internal heap memory
- Returns error code if allocation fails
- Leaves struct in a consistent state

---

## Destruction Pattern

```c
void buffer_destroy(struct Buffer *b) {
    free(b->data);
    b->data = NULL;
    b->size = 0;
    b->capacity = 0;
}
```

Why reset fields?
- Prevent `use-after-free`
- Make double-destroy safe
- Maintain invariant

---

## Why We Separate Allocation from Initialization

Two approaches exist:

**Option A – Stack struct + init**
```c
struct Buffer b;
buffer_init(&b, 100);
buffer_destroy(&b);
```

Ownership:
- Struct → stack
- Internal data → heap

**Option B – Heap struct + create/destroy**
```c
struct Buffer *buffer_create(size_t capacity);
void buffer_free(struct Buffer *b);
```

This is used when:
- Struct itself must outlive scope
- We want *opaque types*

Both patterns are valid. Choose intentionally.

---

## The Most Important Rule

> A struct should never be used unless it has been initialized.

This prevents:
- reading uninitialized pointers
- invalid frees
- broken invariants

---

## Partial Initialization (Danger Zone)

Bad:
```c
b->data = malloc(capacity);
b->size = 0;   // if malloc fails?
```

Correct:
- Set safe defaults on failure
- Always leave struct consistent

---

## Invariants Define Object Validity

A struct has two states:
- **Valid**
- **Destroyed**

After `init` → valid
After `destroy` → invalid but safe

Anything else → bug.

---

## Clean Usage Pattern

```c
struct Buffer b;

if (buffer_init(&b, 100) != 0) {
    return ERROR;
}

/* use b */

buffer_destroy(&b);
```

---

## Why This Matters for Projects

Without this pattern:
- leaks become common
- ownership becomes unclear
- structs drift into valid states
- debugging becomes chaos

With this pattern:
- lifetime is explicit
- invariants are centralized
- error paths are manageable

---

## Relation to C++

This pattern is the conceptual ancestor of:
- constructors
- destructors
- RAII

We are manually implementing disciplined lifetime control.

---

## Takeaway

> - Non-trivial structs require explicit initialization.  
> - Raw memory allocation does not guarantee validity.  
> - Use `Type_init()` and `Type_destroy()` patterns.  
> - Always maintain struct invariants.  
> - Destroy functions should leave structs in a safe state.  
> - Separate memory ownership clearly.  
> - Proper initialization prevents most dynamic memory bugs.  