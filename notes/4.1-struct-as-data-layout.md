# Module 4.1 – `struct` as Data Layout

### Learning Goals

- Explain what a `struct` *really* is in memory
- Understand `struct` as **data layout**, not "an object"
- Predict how fields are laid out in memory
- Understand **padding** and **alignment** (conceptually)
- Decide when a `strcut` is the right abstraction
- Use `struct` as the foundation of APIs

---

## What a `struct` really is

A `struct` in C is **not**:
- an *object*
- a *class*
- a *container with behavior*

A `struct` is:
> A **contiguous block of memory** with **named fields at fixed offset**.

---

## Basic example

```c
struct Point {
    int x;
    int y;
}
```

This defines a **memory layout**:
```
| x (int) | y (int) |
```

If `int` is 4 bytes:
```
| 4 bytes | 4 bytes |
```

Total size: **at least 8 bytes**

---

## Struct groups related data (the real reason they exist)

Without `struct`:
```c
int x, y;
```

With `struct`:
```c
struct Point p;
```

The `struct` expresses:
- logical grouping
- semantic meaning
- invariants ("`x` and `y` belong together)

This is **design**, not syntax.

---

## Structs live wherever variables live

A `struct` can be allocated:

**On the stack**
```c
struct Point p;
```

**On the heap**
```c
struct Point *p = malloc(sizeof(struct Point));
```

**As part of another `struct`**
```c
struct Rect {
    struct Point top_left;
    struct Point bottom_right;
}
```

A `struct` is not special with respect to memory – it follows **all the same rules** we already learned.

---

## Memory layout & sizeof

```c
printf("%zu\n", sizeof(struct Point));
```

This returns:
- the number of byter required to store the `struct`
- including **padding**

Important:
> `sizeof(struct T)` is always safe and correct.

---

## How is a `struct` stored in memory (what happens to field names)?

**Key idea**
> **Field names do not exist in memory.**

They exist:
- in the **source code**
- in the **compiler's understanding**
- in the **debugger's symbols**

But **not in RAM**.

**Example**
```c
struct Point {
    int x;
    int y;
}
```

Let's suppose:
- `int = 4 bytes`
- no padding needed

Memory looks like this:
```
Address:   Value:
0x1000     [ 4 bytes for x ]
0x1004     [ 4 bytes for y ]
```

There is **not trace** of "x" or "y" in memory.

What exists is:
- a contiguous block of bytes
- fixed offsets known at compile time

---

## How the compiler uses field names

When we write:
```c
p.x
```

The compiler:
- knows the offset of `x` inside `struct Point`
- generates code like:
```
*(base_address + offset_of_x)
```

So:
- field names → compile-time mapping
- memory → raw bytes

---

## Padding and alignment (conceptual)

Consider:

```c
struct Example {
    char c;
    int x;
}
```

Memory layout may look like:
```
| c | paddding | padding | padding | x |
```

Why?
- `int` often requires 4-byte alignment
- CPU accesses aligned data faster
- Compiler inserts padding automatically

Key rule:
> **We must never assume field offsets or `struct` size manually.**

Always use:
- `sizeof`
- field access (`.` or `->`)

**Why alignment exists**

Modern CPUs:
- read memory in chunks (often 4, 8, or 16 bytes)
- are **much faster** when data is **aligned**

Example:
- reading an `int` at address `0x1004` → fast
- reading an `int` at address `0x1001` → slower or invalid

So the compiler enforces alignment rules.

**Alignment rule (simplified)**

> **Each type has an alignment requirement.**

| Type | Size | Alignment |
|------|------|-----------|
| `char` | 1 | 1 |
| `int` | 4 | 4 |
| `double` | 8 | 8 |

This means:
- `int` must start at an address divisible by 4
- `double` must start at an address divisible by 8

**Padding example (step-by-step)**
```c
struct Example {
    char c;
    int x;
};
```

Let's walk through layout:
1. `c` (1 byte) → offset 0
2. Next field `x` must be aligned to 4 bytes
3. Currect offset is 1 → not divisible by 4
4. Compiler inserts **3 padding bytes**

Memory:
```
| c | pad | pad | pad | x | x | x | x |
```

Total size = 8 bytes (not 5).

**Why padding is invisible in code**

We cannot:
- access padding bytes
- rely on their value
- assume their existence

They are:
- compiler-inserted
- architecture-dependent
- implementation-defined

That's why:
> **Never manually compute `struct` size or offsets.**

Always use:
```c
sizeof(strcut T)
```

---

## How to access struct fields (syntax + meaning)

**Case 1: Struct variable (on stack or global)**

```c
struct Point p;
p.x = 10;
p.y = 20;
```

Syntax:
```c
variable.field
```

Meaning:
- "access field at known offset from base address"

**Case 2: Pointer to struct (heap or borrowed)**

```c
struct Point *p = malloc(sizeof(struct Point));
p->x = 10;
p->y = 20;
```

Syntax:
```c
pointer->field
```

This is exactly equivalent to:
```c
(*p).x
```

But clearer and safer.

**Why -> exists**

Because this is very common:

```c
(*p).x   // correct but ugly
```

So C provides:
```c
p->x
```

Which means:
> "dereference pointer, then access field"

---

## Access summary (mental model)

| Situation | Syntax | Meaning |
|-----------|--------|---------|
| Struct value | `.` | Access field directly |
| Pointer to struct | `->` | Dereference + access |
| Pointer from | `(*p).x` | Explicit equivalent |

---

## Important constraints

- Field order matters
- Padding may exist between fields
- Padding may exist at the end
- We must not assume:
    - layout
    - size
    - offsets
- Only the compiler knows the real layout

---

## Structs are passive data

This is important philosophically.

In C:
- structs hold data
- functions operate on structs

Example:
```c
void point_move(struct Point *p, int dx, int dy) {
    p->x += dx;
    p->y += dy;
}
```

Behavior lives **outside** the `struct`.

This separation is intentional and powerful.

---

## Struct invariants

An **invariant** is a condition that must always hold.

Example invariants:
- size $\geq$ 0
- pointer is either `NULL` or valid
- length $\leq$ capacity

C does not enforce invariants, but **we must**.

Structs are where invariants *live*.

---

## When should we use a `struct`?

We use a `struct` when:
- Data belongs together
- Fields must move together
- We want to pass related data as one unit
- We want to enforce invariants
- We are designing an API

Avoid structs for:
- single unrelated values
- temporary local grouping

---

## Takeaway

> - A `struct` is a **contiguous block of memory with named fields**.  
> - Structs exist to *group related data*, not behavior.  
> - Struct layout is determined by the compiler and may include **padding**.  
> - `sizeof(struct T)` gives the correct size *including padding*.  
> - Structs can live on the *stack*, *heap*, or *inside other structs*.  
> - Invariants belong to structs but must be enforced manually.  