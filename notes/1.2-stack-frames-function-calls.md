# Module 1.2 - Stack frames and function calls

### Learning goals
- Make the stack model **explicit**.
- Be able to *draw* the stack at any moment during execution.


## What a stacke frame really is

When a function is called in C, the program creates a **stack frame**.

A stack frame contains:
- **space for local variables**
- **function parameters**
- **bookkeeping data (return address, saved registers)**

> **Each function call gets its own stack frame.**

When teh **function returns**:
- its **stack frame** is **destroyed**
- **all its local variables disappear immediately**

---

## One function calling another

**c/fundamentals/stack_frame.c**
```c
#include <stdio.h>

void foo(void) {
    int x = 10;
    printf("foo: x = %d\n", x);
}

void bar(void) {
    int y = 20;
    foo();
    printf("bar: y = %d\n", y);
}

int main(void) {
    int z = 30;
    bar();
    printf("main: z = %d\n", z);
    return 0;
}
```

1. When main starts, what stack frame exists?
**R:** Only the **main's stack frame**.
**S:**

2. When bar() is called, what happens to main’s frame?
**R:** The main's frame still exists. 
**S:** (It becomes the caller frame beneath `bar`).

3. When foo() is called, how many stack frames exist?
**R:** There are **3** stack frames.
**S:** 3(`foo`, `bar` and `main`).

4. Which variables exist while inside foo()?
**R:** Inside `foo()` there is only `x`.
**S:** ==Exist: `x`(`foo`), `y` (`bar`), `z` (`main`) all exist simultaneously.==
==Visible inside `foo`: only `x` (by scope rules).==

5. When foo() returns, what disappears?
**R:** The `foo`'s stack frame.
**S:** (And therefore `x`).

6. When bar() returns, what disappears?
**R:** The `bar`'s stack frame.
**S:** (And therefore `y`).

---

## The correct conceptual stack

While inside `foo()` (during printf):

```

+----------------------+
| #0: foo frame        |
|  x = 10              |
+----------------------+
| #1: bar frame        |
|  y = 20              |
+----------------------+
| #2: main frame       |
|  z = 30              |
+----------------------+
```

Key points:
- **Frames** are ==**stacked**==, **not replaced**.
- **Each functions sees ==only its own locals==**.
- **Lower frames still exist** but are ==**inaccessible directly**==.
- ==**Only the top one is active**==.

---

## Variable lifetime vs visibility

Very important distinction:
- `z` exists during `foo()`
- but `foo()` **cannot access it**

> ==**lifetime ≠ scope**==

**Lifetime**:
- controlled by stack frame existence.

**Scope**:
- controlled by language rules.

---

### Exercise

```c
void f(void) {
    int a = 1;
}

void g(void) {
    int b = 2;
    f();
}

int main(void) {
    int c = 3;
    g();
    return 0;
}
```

1. While inside f(), which variables exist?
**R:** Variables `c`, `b` and `a` exist, but only `a` is accessible.
**S:** (And only `a` is visible from `f`).

2. Which variables are visible?
**R:** From `f()` perspective, only his frame stack is accessible, so only `a` is visible.
**S:** 

3. When does b stop existing?
**R:** When the `g()` function returns.
**S:** (Its frame is destroyed).

4. When does c stop existing?
**R:** When the `main` function returns.
**S:**

---

## Takeaway

> **Every function call creates a new stack frame.**  
> **Stack frames nest.**  
> **When a function returns, its entire frame disappears.**  


---

## Extra exercise (advanced)

```c
int* bad(void) {
    int x = 42;
    return &x;
}
```

What it tries to do:
- Creates a local variable `x` inside `bad`
- Returns a **pointer** to `x`(`&x`)

Why it's wrong (the real reason):
- `x` is a **local (automatic) variable**, stored in **`bad()`'s stack frame**
- When `bad()` returns, **its stack frame is destroyed**
- That means the memory where `x` lived is no longer valid.

> So the returned pointer points to **dead stack memory** (a dangling pointer).

What happens if someone uses it?
If someone does:
```c
int* p = bad();
printf("%d\n", *p);
```

That is **undefined behavior**:
- It might print `42`
- It might print **garbage**
- It might **crash**
- I might ***"work"*** sometimes and fail later

The key concept:
> **Returning the address to a local (stack) variable is invalid because the variable's lifetime ends when the function returns.**
