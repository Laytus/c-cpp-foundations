# Module 2.2 – Arrays vs Pointers (decay)

### Learning Goals
- Explain what **aray-to-pointer decay** is
- Understand **when** arrays decay and **When they do not**
- Explain why arrays and pointers feel similar byt are **not the same**
- Predict what type an array expression has in different contexts
- Avoid the most common array/pointer bugs
- Verify decay behavior using the debugger

---

## The core idea

> **In most expressions, an array decays into a pointer to its first element.**

---

## What "decay" means (conceptually)

Let's consider:
```c
int arr[4] = {10, 20, 30, 40};
```

- `arr` is an **aray**
- It owns 4 contiguous `ints`
- It has a *fixed size*

But in many expressions, C **automatically converts** `arr` into:
```c
&arr[0]
```

That converted vaulue is:
- a pointer
- pointing to the first element
- **type: `int *`**

This automatic conversion is called **array decay**.

---
## Seeing decay in action

**c/fundamentals/array_decay_1.c**
```c
#include <stdio.h>

int main(void) {
    int arr[4] = {10, 20, 30, 40};

    int *p = arr;

    printf("arr[0] = %d\n", arr[0]);
    printf("p      = %d\n", *p);

    return 0;
}
```

What happened?
```c
int *p = arr;
```

This works because:
- `arr` decays to `&arr[0]`
- `&arr[0]` has type `int *`
- Types match

---

## Array name vs pointer variable (key distinction)

Let's compare:
```c
int arr[4];
int *p;
```

**`arr`**
- is an **array**
- owns memory
- size is known at compile time
- cannot be reassigned

```c
arr = p;   // ❌ illegal
```

**`p`**
- is a **pointer**
- stores an address
- does not own memory
- can be reassigned

```c
p = arr;   // ✔ legal (decay)
```

---

## When arrays do NOT decay

Arrays **do not decay** in these contexts:

1. **sizeof**
```c
sizeof(arr)     // size of a entire array
sizeof(p)       // size of a pointer
```

These are **not equal**.

2. **Address-of operator &**

```c
&arr      // type: int (*)[4]
&arr[0]   // type: int *
```

Same numeric address, **different types**.

3. **As function parameterts (syntactic illusion)**

When you write:
```c
void f(int arr[]) { }
```

This is actualy:
```c
void f(int *arr) { }
```

Arrays **cannot be passed by value** in C.

They always decay when passed to functions.

---

## Verify with the debugger

```
p arr
p &arr
p &arr[0]
p p
```

We observe:
- `arr` and `&arr[0]` print the same address
- `&arr` prints the same address but has a different type
- `p` stores the decayed pointer

---

## Why C was designed this way

Historically and practically:
- Arrays are low-level memory blocks
- Passing entire arrays would be expensive
- Decay allows:
    - efficient function calls
    - simple pointer arithmetic
    - flexible APIs

But it also removes safety.

---

## The most common bug this causes

This code looks reasonable but is wrong:
```c
void f(int arr[]) {
    int n = sizeof(arr) / sizeof(arr[0]);  // ❌ wrong
}
```

Why?
- `arr` is actually a **pointer** here
- `sizeof(arr)` is size of a pointer
- Not the array size

This bug is everywhere.

---

## Takeaway

> An array is a fixed-size contiguous block of memory.  
> In most expressions, an array decays to a pointer to its first element.  
> Decay means automatic conversion to `&arr[0]`.  
> Arrays and pointers are not the same, eve if they often behave similarly.  
> Arrays do not decay in `sizeof`, `&`, or as actual objects.  
> Arrays cannot be reassigned; pointers can.  
> Arrays cannot be passed by value in C.  

---