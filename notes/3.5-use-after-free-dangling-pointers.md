# Module 3.5 – `Use-after-free` & Dangling Pointers

### Learning Goals

- Define what a **dangling pointer** is
- Explain what **`use-afte-free`** means
- Understand why these bugs are so hard to detect without tools
- Recognize common patterns that create dangling pointers
- Prevent `use-after-free` bugs by construction
- Use sanitizers to reliably detect them

---

## What is a dangling pointer?

> A **dangling pointer** is a **pointer** that **refers to memory** whose **lifetime has ended**.

That memory:
- may have been freed
- may be reused
- may still contain old data
- is **no longer valid to access**

The pointer still exists. The object does not.

---

## What is `use-after-free`?

> **`Use-after-free`** is **dereferencing** a **pointer** *after* the memory it points to **has been freed**.

Example:
```c
int *p = malloc(sizeof(int));
*p = 42;
free(p);

printf("%d\n", *p);   // ❌ use-after-use (UB)
```

This is undefined behavior.

---

## Why this bug is so deceptive

This code may:
- print 42
- print garbage
- crash
- corrupt other memory
- "work" for weeks

Why?

Because:
- `free` does not erase memory
- the allocator may not reuse it immediately
- the pointer value still looks "reasonable"

This is **exactly why `use-after-free` is dangerous**.

---

## A realistic example (very common)

```c
int *make(void) {
    int *p = malloc(sizeof(int));
    *p = 10;
    return p;
}

void use(void) {
    int *x = make();
    free(x);
    /* ... later ... */
    printf("%d\n", *x);   // ❌ UB
}
```

This bug is **not local**:
- `free` happened earlier
- the crash happens later
- symptoms are disconnected from the cause

---

## Dangling pointers via aliasing

```c
int *p = malloc(sizeof(int));
int *q = p;

free(p);
*q = 5;   // ❌ use-after-free
```

Even though `q` was never freed, it is now dangling.

> **Freeing memory invalidates all pointers to it.**

---

## Why setting to `NULL` matters

This is why we recommended:
```c
free(p);
p = NULL;
```

Now:
```c
*p = 10;   // crashes immediately
```

Instead of silently corrupting memory.

Important:
- This only protects the pointer we set to `NULL`
- Other aliases reamin dangling

So NULL-ing is **helpful, not sufficient**.

---

## `Use-after-free` vs scope-based UB

Let's compare:

**Stack lifetime bug**
```c
int *p;

{
    int x = 5;
    p = &x;
}

printf("%d\n", *p);   // ❌ UB (use-after-scope)
```

**Heap lifetime bug**
```c
int *p = malloc(sizeof(int));
free(p);
printf("%d\n", *p);   // ❌ UB (use-after-free)
```

Different mechanisms. Same fundamental issue: **lifetime ended**.

---

## Detecting `use-after-free`

**With AddressSanitizer (best tool)**

Compile with:
```bash
-fsanitize=address,undefined
```

Typical error:
```
ERROR: AddressSanitizer: heap-use-after-free
```

ASan detects:
- `use-after-free`
- `use-after-scope`
- double free
- invalid free

**With debugger (secondary)**

The debugger can:
- show pointer values
- show memory contents

But it cannot tell us:
- whether memory is still owned
- whether access is legal

Never trust debugger output alone here.

---

## Prevention strategies

1. **Clear ownership rules**
2. **Free exactly once**
3. **Set owned pointers to `NULL` after `free`**
4. **Minimize `aliasing`**
5. **Prefer single-owner patterns**
6. **Use sanitizers early and often**

---

## The core rule

> **A pointer does not extend the lifetime of the memory it points to.**

This rule explains:
- dangling pointers
- `use-after-free`
- most dynamic memory crashes

---

## Takeaway

> A **dangling pointer** refers to memory whose *lifetime* has ended.  
> `Use-after-free` is *dereferencing freed heap memory*.  
> Freed memory may appear to work but is always invalid.  
> Freeing memory invalidates all pointers to it.  
> Setting pointers to `NULL` after `free` improves debuggability.  
> `Use-after-free` bugs are often detected far from their cause.  
> AddressSanitizer is the most reliable detection tool.  